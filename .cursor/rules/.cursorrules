# Cursor AI Rules — Helicopter Component Lifecycle
# (источник: legacy правила + минимальные дополнения без конфликтов)

## 1. Язык и стиль общения
- Вся коммуникация и вывод ассистента — **на русском языке**.
- Короткие, предметные ответы; без лишних уточняющих вопросов, если план уже согласован.

## 2. Принципы проектирования
- **KISS** — решения должны быть максимально простыми и прозрачными.
- **DRY** — общая логика не дублируется; выносим в функции/модули.
- **SoC (Separation of Concerns)** — ETL, инициализация Env, материализация MP, RTC-ядра, статусная логика, логирование и тесты разделены по файлам/слоям.
- **YAGNI** — не реализовывать то, что не подтверждено задачей/потребностью.

## 3. Минимальный дифф
- По умолчанию изменения ограничены **≤ 3 файлами** и **≤ 150 строками**.
- Расширение лимита допускается только с явным обоснованием (в тексте PR/задачи).

## 4. Запрет фейков и хардкода
- Никаких «фейковых» таблиц/данных/результатов.
- Хардкод — только для локальной отладки и с явной пометкой; в PR — убрать или обосновать.

## 5. Безопасность, секреты и доступ
- Секреты и пароли — только в `.env`/vault, не в коде/логах.
- Исключить секреты и артефакты из VCS через `.gitignore`.

## 6. Типы данных
- Предпочтительные типы: `UInt8/16/32`, `Float32`.
- `Float64` применять только по согласованию и с явным описанием причин.
- Выбор типов — на основе фактических диапазонов в источниках (ClickHouse и пр.).

## 7. Рабочие зоны репозитория
- Активная зона разработки: `code/`.
- Архивы/исторические каталоги `archive_*` — **не трогать** без отдельного решения.
- Временные/локальные артефакты — не коммитить; настраивать `.gitignore`.

## 8. Процесс изменений
- Остановиться → описать суть/риски → согласовать → внести правки → прогонить тесты → обновить документацию/чейнджлог.
- По окончании шага — краткое резюме (≤ 5 пунктов): что сделано, где, какие логи/метрики.

## 9. Документация
- Обновлять:
  - `docs/rtc_pipeline_architecture.md` — при изменениях оркестрации/слоёв/RTC.
  - `docs/validation.md` — при изменении инвариантов и проверок.
  - `docs/migration.md` — при существенных архитектурных изменениях.
  - `docs/changelog.md` — каждый PR с описанием/датой/рисками/откатом.

## 10. TaskTracker (файлы задач)
- Реестр: `docs/tasktracker.md` — таблица активных/архивных задач.
- Карточки: `tasks/<YYYY>/<YYYY-MM>/<ID>__<kebab-title>.md` (пример: `tasks/2025/2025-09/TT-142__deferred-state-apply-cascade.md`).
- Статусы: `NEW → SCOPED → IN_PROGRESS → REVIEW → READY_FOR_MERGE → DONE → ARCHIVED` (+ `BLOCKED/ON_HOLD`).
- Каждая карточка содержит: `TaskID`, контекст, план, **DoD**, **AC**, тест-план, артефакты/ссылки, план отката.
- Связность: ветки/коммиты/PR указывают `TaskID`, и наоборот; `changelog` ссылается на `TaskID`.

## 11. Ветки, коммиты, PR
- Ветка: `<type>/<TaskID>__<kebab-title>` (пример: `feat/TT-201__mp5-materialization-once`).
- Коммит: `TT-201: короткое описание (≤72 симв.)`; в теле — контекст/риски/ссылки.
- PR-шаблон: `TaskID`, контекст, логи/скрины, чек-лист DoD/AC, результаты тест-матрицы, влияние на docs/changelog.

## 12. Логирование и трассировка
- На старте: печатать `ACN→frame_idx`, `diag pidx_frame`, выборки `mp5_lin[d0, fi]`/`[d1, fi]`.
- В dev-режиме: `trace_idx timeline` (day, idx, dt, dn, sne, ppr, status).
- Логи должны указывать размеры и checksum критичных массивов (MP5 и т.п.).

## 13. Валидаторы и инварианты (общие)
- Детализация инвариантов обязана быть в `docs/validation.md`.
- Примеры: неизменяемость S6; `Δsne_s2 == sum(dt_s2)`; корректная индексация `base/base_next`; паддинг D+1 и т.д.

## 14. Уборка и поддержание порядка
- Логи/артефакты/временные файлы — в `.gitignore`; удаление — только по правилам.
- Переименование/удаление модулей — PR с планом миграции.
- Заброшенные карточки задач помечаются `STALE` через 14 дней (скриптом).

## 15. Правила поведения ассистента (Cursor/AI)
- Не дробить задачу на избыточные «уточнялки», если план уже согласован.
- Генерация кода: минимальный дифф, тесты/валидации/логи, обновление документации.
- Отчёт по шагу: ≤ 5 пунктов, с конкретикой (файлы, слои, команды).

## 16. FLAME GPU — базовые нормы (общие)
- Не размещать в одном **слое** функции, которые делят общий `initialState` или `endState` — это вызовет `InvalidAgentFunc`.
- Разводить **read/write одного и того же MacroProperty** по разным слоям — иначе риски ошибки 425.
- Порядок слоёв задаёт приоритеты и является частью архитектурных инвариантов.

-------------------------------------------------------------------------------
## 17. Инварианты оркестрации и MP5 (дополнение)
- Один процесс симуляции: единые `ModelDescription` и `CUDASimulation`, без перезагрузки `env` между шагами.
- Размерность кадров: `FRAMES = |MP3 ∪ MP5|` (никакого «расширения впрок»; индексы стабильны).
- `mp5_lin = MacroProperty<UInt32>[(DAYS+1)*FRAMES]` с паддингом D+1.
- Инициализация `mp5_lin` выполняется на хосте **до** первого RTC:
  - через импорт файла/HostFunction; либо (как исключение) одноразовым `rtc_mp5_copy_columns` **только на шаге 0**;
  - после начала чтения агентами `mp5_lin` становится **read-only** (запись запрещена).
- Фиксированные имена ключевых RTC-функций: `rtc_mp5_copy_columns`, `rtc_probe_mp5`, `rtc_status_2`, `rtc_status_4`, `rtc_status_6`, `rtc_transition_*`.
- Любые изменения оркестрации/ядер сопровождаются обновлением `docs/rtc_pipeline_architecture.md` и валидаторов в `docs/validation.md`.

## 18. Тест-матрица и проверки (дополнение)
- Матрица прогонов: `DAYS ∈ {5, 90, 365}` на одном и том же снапшоте; детерминизм обязателен.
- Базовые инварианты (проверяемы валидаторами):
  - S6 неизменяем (нет возврата из 6);
  - Для `status==2`: `Δsne == sum(dt)` за шаг;
  - Индексация MP5: `base = day*FRAMES + idx`, `base_next = base + FRAMES`;
  - Паддинг D+1 корректен (доступ к `dn` на границе).
- Логи по MP5: размеры, контрольная сумма первых блоков, точечные выборки `dt/dn` для трассировки.
- Источник данных для тестов/смоук-прогонов — **только реальные данные** ClickHouse; синтетика — только с явным разрешением владельца задачи/репо.
