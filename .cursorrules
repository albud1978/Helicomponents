# Cursor AI Rules для проекта Helicopter Component Lifecycle

## Запрещенные действия
- НЕ редактировать папку `archive_vnv_cpu_project/` - это архив CPU версии проекта
- НЕ удалять файлы из папки `archive_vnv_cpu_project/`
- НЕ создавать новые файлы в папке `archive_vnv_cpu_project/`
- НЕ удалять любые папки целиком - только отдельные файлы при необходимости

## Активная разработка ведется в папке `code/`
- Все новые изменения должны быть в папке `code/`

## Методология разработки: Анализ → Архитектура → Код
При запросах на доработки ОБЯЗАТЕЛЬНО следовать этапам:

### 1. АНАЛИЗ (сначала)
- Изучить влияние изменений на цикл ETL и связанные скрипты
- Проанализировать зависимости между компонентами системы
- Выявить потенциальные проблемы совместимости

### 2. АРХИТЕКТУРА (затем)
- Разработать проект решения с учетом ETL циклов
- Представить архитектурный план для одобрения пользователем
- Определить последовательность изменений и точки тестирования

### 3. КОД (после одобрения)
- Начинать кодирование ТОЛЬКО после одобрения архитектурного плана
- Следовать утвержденной последовательности изменений
- ВСЕГДА тестировать изменения на каждом этапе
- Запускать полный ETL пайплайн через etl_master.py для проверки совместимости
- Вносить обновления в MD файлы после успешного тестирования

## Ведение документации
Структура документации:
- Все MD файлы хранить в папке `docs/`
- Центральный файл: `docs/README.md` - общая информация, методы доступа к СУБД
- ETL документация: `docs/extract.md`, `docs/transform.md`, `docs/load.md`
- Все остальные документы присоединить к указанным выше
- В каждом документе указывать: перечень скриптов, порядок работы, логику преобразований таблиц
- ОБЯЗАТЕЛЬНО указывать имена таблиц и полей в СУБД
- Код в MD не писать, кроме случаев когда иначе невозможно объяснить логику

## Содержание MD файлов
- Писать ТОЛЬКО факты или то, что согласовано с пользователем
- НЕ придумывать несуществующие компоненты, скрипты или функции
- Описывать только реально существующий код и процессы
- Указывать актуальные названия скриптов, таблиц и полей
- На каждом этапе указывать какие поля в каких таблицах изменяются

## Автоматическая уборка рабочего стола
При запросе на уборку выполнять:

### 1. Очистка временных файлов
- Все папки __pycache__ и файлы *.pyc
- Логи старше 7 дней в logs/
- Файлы *.tmp, *.backup, *.bak

### 2. Очистка отладочных файлов
- Файлы *test*, *debug*, *check*, *analyze* в корне проекта
- НЕ трогать code/archive/ и code/utils/analysis/

### 3. Очистка дублей и копий
- Файлы *_OLD*, *_old*, *_backup*, *_bak*, copy_*, *_copy*
- Дублирующие конфигурационные файлы

### 4. Анализ и реорганизация
ПЕРЕД ПЕРЕНОСОМ СПРАШИВАТЬ РАЗРЕШЕНИЯ:

#### Утилиты из корня → code/utils/
- test_db_connection.py (разовый тест подключений)
- Разовые скрипты очистки СУБД
- Тестовые скрипты НЕ являющиеся частью ETL

#### Скрипты конфигурации → config/
- load_env.sh → config/
- Скрипты настройки окружения

#### В code/ должны остаться ВСЕ ETL скрипты
- Загрузчики (*_loader.py)
- Процессоры статусов (*_processor.py) 
- Обогащение данных (*_enricher.py, *_creator.py)
- etl_master.py (оркестратор)
- dual_loader.py (основной загрузчик)
- calculate_beyond_repair.py (расчеты для ETL)

#### Утилиты = только разовые/вспомогательные
- Тесты подключений
- Очистка СУБД
- Диагностика (НЕ часть основного ETL)
- Утилиты-обертки для удобного ручного запуска (create_all_dictionaries.py)

### 5. Защищенные области (НЕ ТРОГАТЬ)
- archive_vnv_cpu_project/ - полная защита
- code/archive/ - архивные компоненты
- code/utils/ - рабочие утилиты
- data_input/ - входные данные
- docs/ - только 4 основных MD файла

### 6. Защита таблиц СУБД (КРИТИЧНО)
- НЕ УДАЛЯТЬ таблицы, которые НЕ созданы этим проектом
- НЕ УДАЛЯТЬ таблицы в СУБД: OlapCube_VNV, OlapCube_Analytics, Heli_Components
- ЗАПРЕЩЕНО использование DROP TABLE для внешних таблиц
- При работе с таблицами ВСЕГДА проверять что они созданы в рамках этого ETL проекта
- Словарные таблицы создаются двойными: основная + служебная для dictget ClickHouse

### 7. Анализ кода папки code/ на устаревшие скрипты
ПЕРЕД ПЕРЕНОСОМ СПРАШИВАТЬ РАЗРЕШЕНИЯ:

#### Критерии для анализа code/:
- Проверить участие скрипта в ETL_PIPELINE (etl_master.py)
- Проверить импорты в основных ETL скриптах (dual_loader.py и др.)
- Классифицировать: ETL / Утилита / Устаревший

#### Устаревшие скрипты → code/archive/
- Скрипты функциональность которых интегрирована в другие
- НЕ УДАЛЯТЬ - только переносить в архив
- Пример: aircraft_number_dict_creator.py → интегрирован в dictionary_creator.py

#### Утилиты-обертки → code/utils/
- Скрипты для удобного ручного запуска функций ETL
- НЕ участвуют в автоматическом ETL пайплайне
- Пример: create_all_dictionaries.py (обертка для dictionary_creator.py)

### 8. Логика переноса
- ВСЕГДА спрашивать разрешение перед переносом файлов
- Обновлять импорты в скриптах после переноса  
- Тестировать ETL после реорганизации
- Сохранять функциональность системы
- НЕ УДАЛЯТЬ скрипты - только переносить в подходящие папки 