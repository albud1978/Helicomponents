# Правила проекта (консолидировано, 02-01-2026)

## Принципы разработки

### SOLID / DRY / KISS
- **SOLID**: Единая ответственность, открытость/закрытость, подстановка Лисков, разделение интерфейсов, инверсия зависимостей
- **DRY** (Don't Repeat Yourself): Избегать дублирования кода. Выносить общую логику в утилиты
- **KISS** (Keep It Simple, Stupid): Простые решения предпочтительнее сложных. Не усложнять без необходимости

### Порядок работы по архитектуре
1. **Анализ** — AI изучает контекст, формулирует понимание задачи
2. **Предложение** — AI предлагает архитектурное решение (без кода)
3. **Согласование** — Алексей одобряет/корректирует решение
4. **Реализация** — AI пишет код только ПОСЛЕ согласования архитектуры
5. **Ревью** — проверка результата, итерация при необходимости

> ⚠️ **Код БЕЗ предварительного согласования архитектуры — ЗАПРЕЩЁН** для задач с изменением структуры/алгоритмов

---

## Общие правила

- Всегда отвечать на русском языке.
- Рабочая разработка — в `code/`. Архив `archive_vnv_cpu_project/` не трогать.
- Запрещено создавать фейковые файлы/результаты и использовать хардкод (кроме лок. отладки с тестами и фиксацией).
- Минимальный дифф по умолчанию: ≤3 файлов, ≤150 строк, 1 подсистема, без новых публичных API.
- Любые изменения архитектуры/алгоритмов/схем данных — только после явного согласования в чате.
- **Запрещено создавать новые .md файлы без явного разрешения Алексея**, кроме выходных файлов в `output/`.

## Данные и типы
- В СУБД избегать Float64 без согласования. Предпочтать: UInt8/16/32 и Float32.
- MP5 (суточные минуты) — хранить в `UInt16/UInt32` в Env (в соответствии с источником).
- Тесты/прогоны выполнять ТОЛЬКО на реальных данных из ClickHouse. Синтетика/заглушки — только с явным разрешением Алексея в текущем чате.

## Transform / RTC инварианты (v3 - state-based, 22.12.2024)
- Один процесс: единый `ModelDescription` + `CUDASimulation`, без перезагрузки `env` между шагами.
- FRAMES = |MP3 ∪ MP5| (без расширения «впрок»). Индексы для будущих бортов берутся из объединения.
- **Фильтрация планеров**: Из ~7113 строк MP3 агентами становятся только планеры с group_by ∈ {1,2} (~286 бортов).
- MP5 держать в `MacroProperty mp5_lin[MAX_SIZE]` с фиксированным MAX_SIZE; инициализация ТОЛЬКО через HostFunction до первых RTC.
- Запрет записи в `mp5_lin` после начала чтения агентами. RTC копирование запрещено.
- Размеры MacroProperty: MAX_FRAMES определяется из данных MP3/MP5, MAX_DAYS=4000, MAX_SIZE=MAX_FRAMES*(MAX_DAYS+1).
- **OH при создании**: Значения oh (overhaul hours) определять при создании агентов из MP1 по group_by, НЕ в RTC. OH в MP1 уже хранится в минутах, умножать на 60 НЕ НАДО!
  - Использовать `mp1_index` для получения индекса: `pidx = mp1_index.get(partseqno, -1)`
  - Для Mi-8 (group_by=1): брать из `mp1_oh_mi8[pidx]`
  - Для Mi-17 (group_by=2): брать из `mp1_oh_mi17[pidx]`
- **Assembly trigger при создании**: Для агентов в статусе 4 проверять `repair_time - repair_days > assembly_time` и устанавливать `assembly_trigger = 1` если условие выполнено.
- **State-based архитектура**: Использовать FLAME GPU States вместо переменной status_id.
- **Отдельные RTC функции**: Каждое состояние имеет свою RTC функцию для модульности.
- **Разделение логики**: RTC функции состояний НЕ меняют state, только устанавливают intent флаги.
- **Централизованное квотирование**: Единый менеджер квот с приоритетами без атомарных операций.
- **Атомарные переходы**: Все смены состояний в единой RTC функции `rtc_state_transitions`.
- **КРИТИЧНО: Порядок слоёв (layers)**: Модули ДОЛЖНЫ выполняться в строгом порядке согласно матрице состояний (`data_input/analytics/state-intent matrix.xlsx`). См. детали в `docs/rtc_pipeline_architecture.md`.

## Тестирование и валидации (обновлено 13.10.2025)

### Приоритет валидации
- **Основной контроль**: Итоговая выгрузка в СУБД через MP2 (device-side export).
- **Логирование в RTC коде**: Добавляется ТОЛЬКО по явному согласованию Алексея в текущем чате.
- **Удаление логов**: После успешного устранения проблемы код логирования УДАЛЯЕТСЯ + повторное тестирование.
- **Критерий успеха**: Тест считается успешным только при подтверждении результатов в СУБД БЕЗ избыточного логирования.

### Риски логирования в CUDA ядрах
При добавлении `printf` или других операций логирования в RTC ядра учитывать:
- Race conditions (конкурентная запись в stdout от тысяч потоков)
- Потенциальные сбои компиляции NVRTC
- Ограничения FLAME GPU на вывод из device-side кода
- Производительность (логирование может замедлить симуляцию в десятки раз)

### ⚠️ КРИТИЧНО: JIT компиляция RTC ядер
- **Никакие warning'и в JIT логе NVRTC НЕ допускаются!**
- **При КАЖДОЙ компиляции ядер — анализировать JIT лог на warning'и!**
- Warning'и замедляют компиляцию и указывают на потенциальные ошибки
- Типичные проблемы:
  - `warning #117-D`: `return;` вместо `return flamegpu::ALIVE;` в non-void функциях
  - `warning #177-D`: неиспользуемые переменные
- При обнаружении warning'ов — НЕМЕДЛЕННО исправить RTC код

### Матрица тестов
- DAYS={5,90,365,3650}. Детерминизм повторных прогонов на одном снапшоте.
- Для валидации модулей: полный прогон на 3650 дней (все ядра скомпилированы).

### Инварианты
- S6 неизменяем, Δsne_s2 == sum(dt_s2), корректный D+1 паддинг MP5.
- Все проверки инвариантов выполняются SQL-запросами к СУБД.

## Валидация данных heli_pandas
- **Документация**: `docs/data_validation.md` — полное описание логики валидации
- **Скрипт**: `code/analysis/validate_heli_pandas.py`
- **Колонки**: ll_mi8, oh_mi8, br_mi8 (из md_components), error_flags (битовая маска ошибок)
- **Статусы ошибок (10-15)**: проверяются параллельно, без вложенности
  - S10: ll = 0 или NULL
  - S11: target_date < version_date
  - S12: condition != 'ИСПРАВНЫЙ' AND sne = 0
  - S13: sne > ll OR ppr > oh
  - S14: condition NOT IN ('ИСПРАВНЫЙ', 'НЕИСПРАВНЫЙ', 'ДОНОР', 'ВОЗМОЖНОЕ ПРОДЛЕНИЕ НР')
  - S15: condition = 'ДОНОР' AND sne < br (warning)
- **Рабочие статусы (1-6)**: назначаются только если error_flags = 0

## Документация и процесс
- Перед правками — анализ влияния на ETL/скрипты; после — обновление MD только при зелёных тестах.
- **Обязательное ведение**: 4 основных документа при любых изменениях:
  1. `docs/validation.md` — инварианты, тесты, багфиксы
  2. `docs/changelog.md` — история изменений с датами
  3. `docs/rtc_pipeline_architecture.md` — архитектура модулей и принципы
  4. `README.md` — структура проекта, быстрый старт, навигация
- **Связи в документации**: README.md ↔ docs/validation.md ↔ docs/changelog.md ↔ docs/rtc_pipeline_architecture.md ↔ .cursorrules (этот файл).
- **Команда "обновить документацию"**: проверить и обновить все 4 основных файла.
- Обновлять `docs/rtc_pipeline_architecture.md` при изменении оркестрации/ядер/архитектурных принципов.
- Обновлять `docs/validation.md` при изменении проверок, добавлении модулей или обнаружении багов.
- Обновлять `docs/changelog.md` при ЛЮБЫХ изменениях кода (багфиксы, улучшения, рефакторинг).
- Хранить этот файл правил как источник истины.

## Экспертный уровень анализа и разработки (обновлено 19.10.2025)

### Требуемый уровень работы
- **Вы ведущий мировой эксперт по разработке ПО**. Требуется экспертный уровень анализа во всех задачах.
- **Глубокое понимание логики систем**: Перед любым выводом полностью изучить архитектуру, инварианты, граничные условия.
- **Проверка предположений**: Не делать поверхностных выводов. Тщательно анализировать возможные состояния системы.
- **Отказ от шаблонного мышления**: Каждая система имеет уникальную логику — не применять стандартные решения без обоснования.

### Правила диагностики
- **Ошибки диагностики недопустимы**. Если обнаружена собственная ошибка — немедленно её признать, исправить и внести урок.

### Процесс анализа
1. **Читать полный контекст** — архитектурные документы, исходный код, инварианты.
2. **Определить ключевые предположения** — что ОБЯЗАТЕЛЬНО должно быть верно.
3. **Проверить граничные случаи** — нулевые значения, экстремальные ситуации, конфликты.
4. **Перепроверить логику** — особенно для систем с взаимодействиями (квотирование, состояния, переходы).
5. **Скептичный взгляд** — предположить наихудший сценарий для собственного решения.

### Признание ошибок
- При обнаружении ошибки в собственной диагностике: полное признание, исправление, объяснение урока.
- Каждая ошибка — улучшение процесса анализа для будущих задач.
- Примечание: правило добавлено 19.10.2025 после неправильного анализа deficit расчёта в P1.

## Загрузка данных (Extract) — обновлено 01.01.2026

**Extract запускается ТОЛЬКО целиком через extract_master.py:**

```bash
# Из корня проекта (Helicomponents/)
source .venv/bin/activate
python3 code/extract_master.py
```

- Интерактивный выбор датасета из папок `data_input/source_data/v_YYYY-MM-DD/`
- Интерактивный выбор режима: ТЕСТ (полная очистка) или ПРОД (версионирование)
- **ЗАПРЕЩЕНО** запускать отдельные loader-ы вручную без extract_master.py

**Структура датасетов:**
- Каждый датасет в отдельной папке: `v_2025-07-04/`, `v_2025-12-30/` и т.д.
- Обязательные файлы: `Status_Components.xlsx`, `Status_Overhaul.xlsx`, `Program_AC.xlsx`
- Статические файлы (Program_heli.xlsx, Program.xlsx) копируются из первого датасета

## Команда запуска симуляции (обновлено 01.01.2026)

**ОБЯЗАТЕЛЬНЫЙ параметр `--version-date`:**

```bash
# Из корня проекта (Helicomponents/)
source config/load_env.sh
export CUDA_PATH=/usr/local/cuda
cd code/sim_v2

python3 orchestrator_v2.py \
  --version-date 2025-07-04 \
  --modules \
    state_2_operations \
    states_stub \
    count_ops \
    quota_repair \
    quota_ops_excess \
    quota_promote_serviceable \
    quota_promote_reserve \
    quota_promote_inactive \
    spawn_dynamic \
    state_manager_serviceable \
    state_manager_operations \
    state_manager_repair \
    state_manager_storage \
    state_manager_reserve \
    state_manager_inactive \
    spawn_v2 \
  --steps 3650 --enable-mp2 --enable-mp2-postprocess --drop-table
```

**Аргументы симуляции:**
- `--version-date YYYY-MM-DD` — **ОБЯЗАТЕЛЬНО** указать дату датасета
- `--steps N` — количество дней симуляции (по умолчанию 3650 = 10 лет)
- `--enable-mp2` — экспорт результатов в СУБД
- `--enable-mp2-postprocess` — постпроцессинг transition флагов
- `--drop-table` — очистка таблицы sim_masterv2 перед записью

**Ключевые правила порядка модулей:**
1. `spawn_v2` ВСЕГДА в конце (новые агенты проходят логику на следующем шаге)
2. `state_manager_serviceable` ПЕРЕД `state_manager_operations` (холдинг до промоута)
3. Порядок state_manager: serviceable → operations → repair → storage → reserve → inactive
4. `--enable-mp2-postprocess` ОБЯЗАТЕЛЕН для записи transition флагов (1→4, 4→2)

**Источник:** Матрица состояний `data_input/analytics/state-intent matrix.xlsx`  
**Детали:** `docs/rtc_pipeline_architecture.md` (секция "Порядок слоёв")

## Штатные процедуры проверки данных

### Проверка комплектности вертолётов

**Документация:** `docs/extract.md` (секция "Проверка комплектности вертолётов")

**Основная проверка** (какие вертолёты с некомплектом):
```bash
python3 code/heli_pandas_ops_other_groups.py --version-date YYYY-MM-DD --version-id 1 --skip-pdf
```

**Детальная инвентаризация** (каждый агрегат на каждом планере):
```bash
python3 code/heli_pandas_ops_inventory.py --version-date YYYY-MM-DD --version-id 1
```

**Результаты:** 
- `output/heli_pandas_ops_other_groups_YYYY-MM-DD.md`
- `output/heli_pandas_ops_inventory_YYYY-MM-DD.md`

