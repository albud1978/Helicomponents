# Правила проекта (консолидировано, 04-01-2026)

## Принципы разработки

### SOLID / DRY / KISS
- **SOLID**: Единая ответственность, открытость/закрытость, подстановка Лисков, разделение интерфейсов, инверсия зависимостей
- **DRY** (Don't Repeat Yourself): Избегать дублирования кода. Выносить общую логику в утилиты
- **KISS** (Keep It Simple, Stupid): Простые решения предпочтительнее сложных. Не усложнять без необходимости

### Порядок работы по архитектуре
1. **Анализ** — AI изучает контекст, формулирует понимание задачи
2. **Предложение** — AI предлагает архитектурное решение (без кода)
3. **Согласование** — Алексей одобряет/корректирует решение
4. **Реализация** — AI пишет код только ПОСЛЕ согласования архитектуры
5. **Ревью** — проверка результата, итерация при необходимости

> ⚠️ **Код БЕЗ предварительного согласования архитектуры — ЗАПРЕЩЁН** для задач с изменением структуры/алгоритмов

---

## Общие правила

- Всегда отвечать на русском языке.
- Рабочая разработка — в `code/`. Архив `archive_vnv_cpu_project/` не трогать.
- Запрещено создавать фейковые файлы/результаты и использовать хардкод (кроме лок. отладки с тестами и фиксацией).
- Минимальный дифф по умолчанию: ≤3 файлов, ≤150 строк, 1 подсистема, без новых публичных API.
- Любые изменения архитектуры/алгоритмов/схем данных — только после явного согласования в чате.
- **Запрещено создавать новые .md файлы без явного разрешения Алексея**, кроме выходных файлов в `output/`.

## Данные и типы
- В СУБД избегать Float64 без согласования. Предпочтать: UInt8/16/32 и Float32.
- MP5 (суточные минуты) — хранить в `UInt16/UInt32` в Env (в соответствии с источником).
- Тесты/прогоны выполнять ТОЛЬКО на реальных данных из ClickHouse. Синтетика/заглушки — только с явным разрешением Алексея в текущем чате.

## Transform / RTC инварианты (v3 - state-based, 22.12.2024)
- Один процесс: единый `ModelDescription` + `CUDASimulation`, без перезагрузки `env` между шагами.
- FRAMES = |MP3 ∪ MP5| (без расширения «впрок»). Индексы для будущих бортов берутся из объединения.
- **Фильтрация планеров**: Из ~7113 строк MP3 агентами становятся только планеры с group_by ∈ {1,2} (~286 бортов).
- MP5 держать в `MacroProperty mp5_lin[MAX_SIZE]` с фиксированным MAX_SIZE; инициализация ТОЛЬКО через HostFunction до первых RTC.
- Запрет записи в `mp5_lin` после начала чтения агентами. RTC копирование запрещено.
- Размеры MacroProperty: **RTC_MAX_FRAMES=400** (фиксированный для кэширования ядер), MAX_DAYS=4000, MAX_SIZE=400*4001=1,600,400.
- Runtime `frames_total` передаётся через Environment для индексации внутри ядер (реальное количество агентов).
- **OH при создании**: Значения oh (overhaul hours) определять при создании агентов из MP1 по group_by, НЕ в RTC. OH в MP1 уже хранится в минутах, умножать на 60 НЕ НАДО!
  - Использовать `mp1_index` для получения индекса: `pidx = mp1_index.get(partseqno, -1)`
  - Для Mi-8 (group_by=1): брать из `mp1_oh_mi8[pidx]`
  - Для Mi-17 (group_by=2): брать из `mp1_oh_mi17[pidx]`
- **Assembly trigger при создании**: Для агентов в статусе 4 проверять `repair_time - repair_days > assembly_time` и устанавливать `assembly_trigger = 1` если условие выполнено.
- **State-based архитектура**: Использовать FLAME GPU States вместо переменной status_id.
- **Отдельные RTC функции**: Каждое состояние имеет свою RTC функцию для модульности.
- **Разделение логики**: RTC функции состояний НЕ меняют state, только устанавливают intent флаги.
- **Централизованное квотирование**: Единый менеджер квот с приоритетами без атомарных операций.
- **Атомарные переходы**: Все смены состояний в единой RTC функции `rtc_state_transitions`.
- **КРИТИЧНО: Порядок слоёв (layers)**: Модули ДОЛЖНЫ выполняться в строгом порядке согласно матрице состояний (`data_input/analytics/state-intent matrix.xlsx`). См. детали в `docs/rtc_pipeline_architecture.md`.
- **br2_mi17 (порог межремонтного)**: При подъёме Mi-17 из inactive: если ppr < br2_mi17 (3500ч) → комплектация без ремонта (ppr сохраняется) + **пропуск ожидания repair_time**, иначе → ремонт (ppr = 0) + ожидание repair_time. Для Mi-8 всегда ремонт. См. `docs/rtc_components.md` раздел 7.2.

## Тестирование и валидации (обновлено 13.10.2025)

### Приоритет валидации
- **Основной контроль**: Итоговая выгрузка в СУБД через MP2 (device-side export).
- **Логирование в RTC коде**: Добавляется ТОЛЬКО по явному согласованию Алексея в текущем чате.
- **Удаление логов**: После успешного устранения проблемы код логирования УДАЛЯЕТСЯ + повторное тестирование.
- **Критерий успеха**: Тест считается успешным только при подтверждении результатов в СУБД БЕЗ избыточного логирования.

### Риски логирования в CUDA ядрах
При добавлении `printf` или других операций логирования в RTC ядра учитывать:
- Race conditions (конкурентная запись в stdout от тысяч потоков)
- Потенциальные сбои компиляции NVRTC
- Ограничения FLAME GPU на вывод из device-side кода
- Производительность (логирование может замедлить симуляцию в десятки раз)

### ⚠️ КРИТИЧНО: JIT компиляция RTC ядер
- **Никакие warning'и в JIT логе NVRTC НЕ допускаются!**
- **При КАЖДОЙ компиляции ядер — анализировать JIT лог на warning'и!**
- Warning'и замедляют компиляцию и указывают на потенциальные ошибки
- Типичные проблемы:
  - `warning #117-D`: `return;` вместо `return flamegpu::ALIVE;` в non-void функциях
  - `warning #177-D`: неиспользуемые переменные
- При обнаружении warning'ов — НЕМЕДЛЕННО исправить RTC код

### Матрица тестов
- DAYS={5,90,365,3650}. Детерминизм повторных прогонов на одном снапшоте.
- Для валидации модулей: полный прогон на 3650 дней (все ядра скомпилированы).

### Инварианты
- S6 неизменяем, Δsne_s2 == sum(dt_s2), корректный D+1 паддинг MP5.
- Все проверки инвариантов выполняются SQL-запросами к СУБД.

## Валидация данных heli_pandas
- **Документация**: `docs/data_validation.md` — полное описание логики валидации
- **Скрипт**: `code/analysis/validate_heli_pandas.py`
- **Колонки**: ll_mi8, oh_mi8, br_mi8 (из md_components), error_flags (битовая маска ошибок)
- **Статусы ошибок (10-15)**: проверяются параллельно, без вложенности
  - S10: ll = 0 или NULL
  - S11: target_date < version_date
  - S12: condition != 'ИСПРАВНЫЙ' AND sne = 0
  - S13: sne > ll OR ppr > oh
  - S14: condition NOT IN ('ИСПРАВНЫЙ', 'НЕИСПРАВНЫЙ', 'ДОНОР', 'ВОЗМОЖНОЕ ПРОДЛЕНИЕ НР')
  - S15: condition = 'ДОНОР' AND sne < br (warning)
- **Рабочие статусы (1-6)**: назначаются только если error_flags = 0

## Документация и процесс
- Перед правками — анализ влияния на ETL/скрипты; после — обновление MD только при зелёных тестах.
- **Обязательное ведение**: 4 основных документа при любых изменениях:
  1. `docs/validation.md` — инварианты, тесты, багфиксы
  2. `docs/changelog.md` — история изменений с датами
  3. `docs/rtc_pipeline_architecture.md` — архитектура модулей и принципы
  4. `README.md` — структура проекта, быстрый старт, навигация
- **Связи в документации**: README.md ↔ docs/validation.md ↔ docs/changelog.md ↔ docs/rtc_pipeline_architecture.md ↔ .cursorrules (этот файл).
- **Команда "обновить документацию"**: проверить и обновить все 4 основных файла.
- Обновлять `docs/rtc_pipeline_architecture.md` при изменении оркестрации/ядер/архитектурных принципов.
- Обновлять `docs/validation.md` при изменении проверок, добавлении модулей или обнаружении багов.
- Обновлять `docs/changelog.md` при ЛЮБЫХ изменениях кода (багфиксы, улучшения, рефакторинг).
- Хранить этот файл правил как источник истины.

## Экспертный уровень анализа и разработки (обновлено 19.10.2025)

### Требуемый уровень работы
- **Вы ведущий мировой эксперт по разработке ПО**. Требуется экспертный уровень анализа во всех задачах.
- **Глубокое понимание логики систем**: Перед любым выводом полностью изучить архитектуру, инварианты, граничные условия.
- **Проверка предположений**: Не делать поверхностных выводов. Тщательно анализировать возможные состояния системы.
- **Отказ от шаблонного мышления**: Каждая система имеет уникальную логику — не применять стандартные решения без обоснования.

### Правила диагностики
- **Ошибки диагностики недопустимы**. Если обнаружена собственная ошибка — немедленно её признать, исправить и внести урок.

### Процесс анализа
1. **Читать полный контекст** — архитектурные документы, исходный код, инварианты.
2. **Определить ключевые предположения** — что ОБЯЗАТЕЛЬНО должно быть верно.
3. **Проверить граничные случаи** — нулевые значения, экстремальные ситуации, конфликты.
4. **Перепроверить логику** — особенно для систем с взаимодействиями (квотирование, состояния, переходы).
5. **Скептичный взгляд** — предположить наихудший сценарий для собственного решения.

### Признание ошибок
- При обнаружении ошибки в собственной диагностике: полное признание, исправление, объяснение урока.
- Каждая ошибка — улучшение процесса анализа для будущих задач.
- Примечание: правило добавлено 19.10.2025 после неправильного анализа deficit расчёта в P1.

## Настройка окружения — ОБЯЗАТЕЛЬНО перед любыми командами

```bash
cd /media/albud/8C327EB0327E9F40/Projects/Heli/Helicomponents
source .venv/bin/activate
source config/load_env.sh
export CUBE_CONFIG_PATH="/media/albud/8C327EB0327E9F40/Projects/Heli/Helicomponents/config"
```

---

## Загрузка данных (Extract) — обновлено 03.01.2026

**Extract запускается ТОЛЬКО целиком через extract_master.py:**

### Интерактивный режим (в терминале)
```bash
python3 code/extract_master.py
```

### Автоматический режим (для скриптов/AI)
```bash
# Датасет 1 (2025-07-04), режим TEST (полная очистка)
printf "1\n1\n" | python3 code/extract_master.py --mode TEST

# Датасет 2 (2025-12-30), режим PROD (версионирование, сохраняет данные других версий)
printf "2\n2\n" | python3 code/extract_master.py --mode PROD
```

**Важно:** Первый датасет грузить в режиме TEST, последующие — в режиме PROD!

### Правила загрузки
- Интерактивный выбор: 1=датасет 1, 2=датасет 2; 1=TEST, 2=PROD
- **ЗАПРЕЩЕНО** запускать отдельные loader-ы вручную без extract_master.py

**Структура датасетов:**
- Каждый датасет в отдельной папке: `v_2025-07-04/`, `v_2025-12-30/` и т.д.
- Обязательные файлы: `Status_Components.xlsx`, `Status_Overhaul.xlsx`, `Program_AC.xlsx`
- Статические файлы (Program_heli.xlsx, Program.xlsx) копируются из первого датасета

---

## Симуляция (FLAME GPU) — обновлено 03.01.2026

### RTC кэширование ядер
- **RTC_MAX_FRAMES = 400** — фиксированный размер MacroProperty для всех датасетов
- Ядра компилируются ОДИН раз при первом запуске (~8 мин), далее используется кэш
- Кэш: `.rtc_cache/` (~266 файлов после полного прогона с MP2)
- При смене датасета перекомпиляция НЕ требуется (размеры одинаковые)

### Производительность (3650 дней × ~300 агентов)
| Метрика | Значение |
|---------|----------|
| Общее время | ~80с (1.3 мин) |
| Чистое GPU | ~34с |
| Drain в СУБД | ~38с |
| Записей | ~1.1 млн |
| RTC calls/sec | ~1.3 млн |
| Ускорение vs CPU | ~32x |

### Полная команда симуляции

```bash
cd code/sim_v2 && python3 orchestrator_v2.py \
  --version-date 2025-07-04 \
  --modules state_2_operations states_stub count_ops quota_repair quota_ops_excess \
    quota_promote_serviceable quota_promote_reserve quota_promote_inactive spawn_dynamic \
    compute_transitions \
    state_manager_serviceable state_manager_operations state_manager_repair \
    state_manager_storage state_manager_reserve state_manager_inactive spawn_v2 \
  --steps 3650 --enable-mp2 --enable-mp2-postprocess --drop-table
```

### Аргументы симуляции
- `--version-date YYYY-MM-DD` — **ОБЯЗАТЕЛЬНО** указать дату датасета
- `--steps N` — количество дней симуляции (3650 = 10 лет)
- `--enable-mp2` — экспорт результатов в СУБД (sim_masterv2)
- `--enable-mp2-postprocess` — постпроцессинг transition флагов (1→4, 4→2)
- `--drop-table` — очистка таблицы sim_masterv2 перед записью (для первого датасета)

### Ключевые правила порядка модулей
1. `spawn_v2` ВСЕГДА в конце (новые агенты проходят логику на следующем шаге)
2. `state_manager_serviceable` ПЕРЕД `state_manager_operations` (холдинг до промоута)
3. Порядок state_manager: serviceable → operations → repair → storage → reserve → inactive
4. `--enable-mp2-postprocess` ОБЯЗАТЕЛЕН для записи transition флагов

### Очистка RTC кэша (только при изменении RTC кода!)
```bash
rm -rf .rtc_cache/* ~/.cache/flamegpu/* /tmp/flamegpu/*
```

**Источник:** Матрица состояний `data_input/analytics/state-intent matrix.xlsx`  
**Детали:** `docs/rtc_pipeline_architecture.md`, `docs/validation.md` (секция MAX_FRAMES)

---

## Проверка комплектности вертолётов

**Документация:** `docs/extract.md` (секция "Проверка комплектности вертолётов")

### Основная проверка (какие вертолёты с некомплектом)
```bash
python3 code/heli_pandas_ops_other_groups.py --version-date 2025-07-04 --version-id 1 --skip-pdf
```

### Детальная инвентаризация (каждый агрегат на каждом планере)
```bash
python3 code/heli_pandas_ops_inventory.py --version-date 2025-07-04 --version-id 1
```

### Результаты
- `output/heli_pandas_ops_other_groups_YYYY-MM-DD.md`
- `output/heli_pandas_ops_inventory_YYYY-MM-DD.md`

---

## Доступные датасеты (январь 2026)

| Датасет | Планеров | В ops | heli_pandas | flight_program_fl |
|---------|----------|-------|-------------|-------------------|
| `v_2025-07-04` | 279 | 154 | 10,913 | 1,164,000 (dates: 2025-07-04 — 2036-06-15) |
| `v_2025-12-30` | 285 (+6) | 158 | 11,389 | 1,164,000 (dates: 2025-12-30 — 2036-12-11) |

**Мультиверсионность:**
- Каждый датасет имеет свой `version_date` в таблицах `flight_program_fl`, `flight_program_ac`
- При симуляции `preload_mp5_maps` и `preload_mp4_by_day` фильтруют по `version_date`
- `day_0` симуляции = `version_date` датасета (автоматический маппинг)

