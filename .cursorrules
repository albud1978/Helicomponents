# Cursor AI Rules для проекта Helicopter Component Lifecycle

Always respond in Russian

Меня зовут Алексей. Сейчас ты запущен в Cursor AI в Windows 11 под WSL в Ubuntu 22.04. 
Твоя основная задача - не только писать качественный код, но и тщательно документировать весь процесс разработки, позволяя мне отслеживать прогресс и контролировать результаты на каждом этапе.

Мы делаем проект имитационной модели оборота вертолетных агрегатов.
Данные загружаются из Excel.

## Запрещенные действия
- НЕ редактировать папку `archive_vnv_cpu_project/` - это архив CPU версии проекта
- НЕ удалять файлы из папки `archive_vnv_cpu_project/`
- НЕ создавать новые файлы в папке `archive_vnv_cpu_project/`
- НЕ удалять любые папки целиком - только отдельные файлы при необходимости
- **ЗАПРЕЩЕНО создавать фейковые файлы** - скрипты должны выполнять реальную работу, кроме случаев локальной отладки с последующим переносом и тестированием на реальном коде
- **ЗАПРЕЩЕН хардкод без разрешения** - кроме локальной отладки с обязательным тестированием

### Уточнение по удалению объектов (24-08-2025)
- **ЗАПРЕЩЕНО удалять объекты проекта без явного подтверждения пользователя** (Алексея) в текущем чате, даже если удаление было согласовано на уровне архитектурного плана.
- Под «объектами проекта» понимаются: файлы и каталоги в репозитории, таблицы/представления в СУБД, документы в `docs/`.
- Исключения не допускаются: любое удаление — только после прямого подтверждения в чате.

## Активная разработка ведется в папке `code/`
- Все новые изменения должны быть в папке `code/`

## Методология разработки: Анализ → Архитектура → Код
При запросах на доработки ОБЯЗАТЕЛЬНО следовать этапам:

### 1. АНАЛИЗ (сначала)
- Изучить влияние изменений на цикл ETL и связанные скрипты
- Проанализировать зависимости между компонентами системы
- Выявить потенциальные проблемы совместимости

### 2. АРХИТЕКТУРА (затем)
- Разработать проект решения с учетом ETL циклов
- Представить архитектурный план для одобрения пользователем
- Определить последовательность изменений и точки тестирования

### 3. КОД (после одобрения)
- Начинать кодирование ТОЛЬКО после одобрения архитектурного плана
- Следовать утвержденной последовательности изменений
- ВСЕГДА тестировать изменения на каждом этапе
- Запускать полный ETL пайплайн через extract_master.py для проверки совместимости
- Вносить обновления в MD файлы после успешного тестирования

### 4. СТРОГИЙ ЗАПРЕТ НА ПОДМЕНУ АЛГОРИТМОВ
- ЗАПРЕЩЕНО изменять алгоритмы расчетов без ЯВНОГО одобрения пользователя
- НЕ ПОДМЕНЯТЬ математические формулы хардкодом или упрощениями
- НЕ ИЗМЕНЯТЬ логику расчетов без предварительного анализа и согласования
- Перед любыми изменениями в алгоритмах ОБЯЗАТЕЛЬНО:
  * Представить анализ текущего алгоритма
  * Объяснить необходимость изменений
  * Получить ЯВНОЕ одобрение от пользователя
  * Показать сравнение результатов до и после изменений

### 5. СТРОГИЙ КОНТРОЛЬ ТИПОВ ДАННЫХ
- **ЗАПРЕЩЕНО использовать Float64 в СУБД без ЯВНОГО согласования пользователя**
- **ОБЯЗАТЕЛЬНО спрашивать пользователя при сомнениях в выборе типа данных**
- **Приоритет типов данных для оптимизации:**
  * UInt8 (0-255) для счетчиков, флагов, малых значений
  * UInt16 (0-65535) для средних значений, ID
  * UInt32 (0-4млрд) для больших значений, первичных ключей
  * Float32 для денежных и расчетных значений (вместо Float64)
  * String только для текстовых полей
- **Перед использованием Float64 ОБЯЗАТЕЛЬНО:**
  * Обосновать необходимость высокой точности
  * Получить ЯВНОЕ одобрение от пользователя
  * Рассмотреть альтернативы (UInt32, Float32)
- При обнаружении потенциальных проблем в алгоритмах - СООБЩИТЬ пользователю, НЕ ИСПРАВЛЯТЬ самостоятельно
- **КРИТИЧНОСТЬ ОШИБОК В ПАЙПЛАЙНЕ**: НИКАКИЕ ошибки алгоритмов в Extract/Transform/Load пайплайне НЕ МОГУТ быть интерпретированы как "некритичные". Любой провал этапа означает системную проблему, требующую устранения
- Данное правило распространяется на ВСЕ расчетные функции проекта, включая Beyond Repair, словари, ETL преобразования

#### 5.2 Запрет «неважных этапов» и «тихих пропусков» (05-09-2025)
- Любой этап пайплайна считается важным; понятия «неважный этап» не существует.
- Запрещено предлагать или реализовывать «тихий пропуск» этапа (continue on error) и деградацию функциональности при ошибках.
- При появлении новой зависимости между этапами допускается только:
  * Явная перестановка этапов с согласованием, либо
  * Добавление отдельного завершающего обогащающего этапа, не ломающего текущую логику существующих этапов.
- Любая ошибка этапа должна приводить к остановке пайплайна и устранению причины, а не к продолжению с частично загруженными данными.

#### 5.1 Назначение типов для новых данных (обоснование от источника)
- Типы в GPU‑Env назначать, исходя из типов источника (ClickHouse/Excel) и фактических диапазонов значений. Любое отклонение от типа источника — только с обоснованием.
- Обоснование обязательно фиксировать в документации (docs/changelog.md или соответствующем MD): указывать таблицу/поле, исходный тип, целевой тип, диапазон значений, причину изменения (память/производительность/совместимость NVRTC), а также влияние на RTC.
- Чек‑лист перед изменением типа:
  1) Таблица/поле‑источник и исходный тип данных
  2) Предлагаемый целевой тип в Env
  3) Диапазон значений (min/max, кардинальность)
  4) Причины выбора (GPU специфика, экономия, точность, NVRTC совместимость)
  5) Ссылки на тест/прогон (смоук/инварианты)
- Специфика MP5.daily_hours: источник — целочисленные минуты; в Env хранить как UInt16. Запрещено повышать до UInt32 без явного обоснования и подтверждённых тестов.

### 4.1. ЗАПРЕТ НА УДАЛЕНИЕ ТАБЛИЦ И СТОЛБЦОВ В ДОКУМЕНТАЦИИ
- **СТРОГО ЗАПРЕЩЕНО** удалять таблицы и столбцы из MD файлов без явного разрешения пользователя
- **РАЗРЕШЕНЫ** только изменения содержимого ячеек:
  * Исправление данных в существующих ячейках
  * Добавление новых строк в таблицы
  * Удаление строк из таблиц (если обосновано)
- **ЗАПРЕЩЕНЫ** структурные изменения:
  * Удаление целых таблиц
  * Удаление столбцов из таблиц
  * Изменение структуры заголовков таблиц
  * Переименование столбцов без согласования
- **Перед структурными изменениями ОБЯЗАТЕЛЬНО:**
  * Обосновать необходимость изменения структуры
  * Получить ЯВНОЕ одобрение от пользователя
  * Показать что именно будет изменено и почему
- **При обнаружении избыточности в документации:**
  * СООБЩИТЬ пользователю о проблеме
  * ПРЕДЛОЖИТЬ варианты решения
  * НЕ УДАЛЯТЬ контент самостоятельно

### 5. СИНХРОННЫЕ ИЗМЕНЕНИЯ ЛОГИКИ TRANSFORM (31-07-2025)
- **КРИТИЧНО**: Все изменения логики симуляции и RTC функций ОБЯЗАТЕЛЬНО рассматривать синхронно с пользователем
- **ЗАПРЕЩЕНО самостоятельно изменять**:
  * Алгоритмы балансировки агентов
  * Условия триггеров RTC функций  
  * Логику переходов между статусами
  * Формулы расчета переменных (sne, ppr, repair_days)
- **ОБЯЗАТЕЛЬНАЯ СИНХРОНИЗАЦИЯ**:
  * Любые изменения в JSON конфигурациях RTC
  * Модификации архитектуры симуляций
  * Корректировки условий spawn/balance
  * Изменения в MacroProperty структурах
- **ПРОЦЕДУРА**: 
  1. ОСТАНОВИТЬСЯ при любых изменениях логики
  2. ОПИСАТЬ пользователю суть изменений
  3. ПОЛУЧИТЬ явное одобрение
  4. ТОЛЬКО ПОТОМ вносить изменения
- **ИСКЛЮЧЕНИЯ**: Техническая отладка с ОБЯЗАТЕЛЬНЫМ уведомлением пользователя

### 6. ХАРДКОД И ДОКУМЕНТАЦИЯ
- ЛЮБОЙ хардкод ОБЯЗАТЕЛЬНО описывать в документации по соответствующему разделу разработки
- Документация хардкода должна включать:
  * Подробное описание логики с таблицами и полями
  * Причины использования хардкода
  * Значения констант и их обоснование
  * Планы на будущий рефакторинг
  * Примеры использования и тестовые случаи
- Хардкод может быть временным решением, но ВСЕГДА должен быть задокументирован для будущего рефакторинга

### 6. ЗАПРЕТ НА ФЕЙКОВЫЕ ФАЙЛЫ И DUMMY РЕАЛИЗАЦИИ
- **СТРОГО ЗАПРЕЩЕНО создавать фейковые файлы** - скрипты/визуализации/отчеты, которые НЕ выполняют реальную работу
- **ЗАПРЕЩЕНЫ dummy/mock реализации** без ЯВНОГО предупреждения пользователю
- **ЗАПРЕЩЕНЫ имитации технологий** (например, Python код вместо настоящего FLAME GPU, C++, CUDA)
- **ЗАПРЕЩЕНЫ фейковые комментарии** типа "# TODO: Реализовать позже" без реальной реализации
- **ОБЯЗАТЕЛЬНОЕ ПРЕДУПРЕЖДЕНИЕ**: Перед созданием любых заглушек или подготовительного кода ВСЕГДА предупреждать пользователя что это НЕ финальная реализация
- **Исключение**: локальная отладка с ОБЯЗАТЕЛЬНЫМ:
  * ЯВНЫМ предупреждением пользователю о природе кода
  * Переносом в соответствующие папки после отладки  
  * Тестированием реального кода на реальных данных
  * Удалением временных отладочных файлов после завершения
  * Документированием отладочного процесса
- **При нарушении**: архивирование с полным описанием в changelog

### 7. УПРАВЛЕНИЕ ПАМЯТЬЮ И ПРАВИЛАМИ
- **ОБЯЗАТЕЛЬНОЕ ВЕДЕНИЕ ПАМЯТИ**: При обнаружении системных ошибок, неправильных подходов или важных уроков ВСЕГДА создавать записи в памяти
- **КРИТИЧЕСКИЙ ЗАПРОС**: После каждого использования update_memory ВСЕГДА спрашивать пользователя: "Нужно ли отразить эти изменения в .cursorrules?"
- **ПРАВИЛА ОБНОВЛЯЮТСЯ**: Если пользователь подтверждает - немедленно обновлять .cursorrules с новыми правилами или уточнениями
- **ПРИОРИТЕТ ПАМЯТИ**: Записи в памяти имеют приоритет над общими инструкциями - если память противоречит инструкции, следовать памяти
- **ПАМЯТЬ О СИСТЕМНЫХ ОШИБКАХ**: Все технические ошибки (неправильный выбор технологий, dummy реализации, архитектурные промахи) обязательно записывать в память
- **КОНСУЛЬТАЦИЯ ПРАВИЛ**: Перед началом любой значительной разработки проверять как память, так и .cursorrules на предмет релевантных ограничений

## Процесс разработки

 1. Не требуй предварительного подтверждения перед началом шага; действуй по согласованному плану.
 2. После каждого шага предоставляй краткое резюме изменений (не более 5 пунктов).
 3. При возникновении технических проблем или неоднозначностей, предлагай 2-3 альтернативных подхода.
 4. Всегда сохраняй контекст текущей задачи и общую цель проекта.
 5. Периодически напоминай о текущем статусе задачи и оставшихся шагах.
 6. Следуй архитектурным решениям и стандартам, описанным в README.md.
 7. Соблюдай принципы SOLID, KISS, DRY.
 8. Проводи code review для всех изменений.
 9. Используйте единый стиль кодирования (линтеры, pre-commit hooks)
10. Не оставляйте неиспользуемый код и комментарии.
10.1. **ОБЯЗАТЕЛЬНОЕ ТЕСТИРОВАНИЕ**: Любой код ОБЯЗАТЕЛЬНО тестировать на реальных данных перед предоставлением пользователю
10.2. **ЗАПРЕТ НА ФЕЙКИ В КОДЕ**: НЕ создавать функции-заглушки, фейковые данные или имитации без явного разрешения
11. **ГОТОВНОСТЬ ЗАДАЧИ ПРИНИМАЕТ ТОЛЬКО ПОЛЬЗОВАТЕЛЬ**: НЕ меняй статус задачи на "Завершена" самостоятельно. Готовность задачи определяет и принимает только пользователь. Статус задачи изменяется на "Завершена" ТОЛЬКО после явного одобрения пользователем.
12. **ОБЯЗАТЕЛЬНОЕ ИЗУЧЕНИЕ ДОКУМЕНТАЦИИ**: При разработке любой задачи СНАЧАЛА изучи соответствующую документацию в папке `docs/`. НЕ начинай кодирование без понимания архитектуры, последовательности этапов и зависимостей, описанных в MD файлах. Документация содержит критически важную информацию о структуре данных, алгоритмах и интеграции компонентов.

## Коммуникация

1. Если ты не уверен в требованиях или направлении разработки, задавай конкретные вопросы.
2. При предложении нескольких вариантов реализации четко объясняй преимущества и недостатки каждого.
3. Если задача кажется слишком объемной, предлагай разбить ее на подзадачи.
4. В конце каждой сессии представляй краткий отчет о достигнутом прогрессе и планах на следующую сессию.

## Ведение документации
Структура документации:
- Все MD файлы хранить в папке `docs/`
- Центральный файл: `docs/README.md` - общая информация, методы доступа к СУБД
- ETL документация: `docs/extract.md`, `docs/transform.md`, `docs/load.md`, `docs/changelog.md`
- Управление задачами: `docs/Tasktracker.md` - статус выполнения задач с описанием
- Changelog.md - хронологический журнал всех изменений
- Все остальные документы присоединить к указанным выше
- В каждом документе указывать: перечень скриптов, порядок работы, логику преобразований таблиц
- ОБЯЗАТЕЛЬНО указывать имена таблиц и полей в СУБД
- Код в MD не писать, кроме случаев когда иначе невозможно объяснить логику

## Правила датирования в документации
- При обновлении документации ВСЕГДА использовать АКТУАЛЬНУЮ системную дату
- НЕ ИСПОЛЬЗОВАТЬ фиксированные даты типа "19-07-2025" 
- Получать дату через команду `date` или системные функции
- Формат даты в changelog: `## [DD-MM-YYYY]` где DD-MM-YYYY - текущая системная дата
- Формат даты в комментариях кода: `Дата: YYYY-MM-DD` (текущая дата)
- При создании новых записей в Tasktracker указывать актуальную дату завершения
- При обновлении статуса задач обновлять временные метки на текущую дату

## Содержание MD файлов
- Писать ТОЛЬКО факты или то, что согласовано с пользователем
- НЕ придумывать несуществующие компоненты, скрипты или функции
- Описывать только реально существующий код и процессы
- Указывать актуальные названия скриптов, таблиц и полей
- На каждом этапе указывать какие поля в каких таблицах изменяются

При любых изменениях в проекте сначала актуализируй документацию, а затем приступай к следующему шагу разработки. Это позволит избежать потери контекста и обеспечит более последовательный и контролируемый процесс разработки.

## Автоматическая уборка рабочего стола

### Принципы безопасной уборки (обновлено 19-07-2025)

**Агентный анализ вместо массовых операций:**
- Анализ фактического состояния проекта перед действиями
- Целевая очистка только реально найденных проблем
- Сохранение текущей рабочей структуры без реорганизации

**Что очищается автоматически:**
- Временные файлы Python (__pycache__, *.pyc)
- Логи старше 7 дней в logs/
- Файлы *.tmp, *.backup, *.bak (если найдены)
- Дублирующие файлы *_backup, *_copy (если найдены)
- Артефакты неудачных команд (=*.*.*, path==*, *==*.*.*)
- Временные файлы установки (*.whl, *.tar.gz, *.zip в корне)
- Логи и кэши (.log, .tmp, .cache, .download в корне)

**Что НЕ трогается:**
- Текущая структура папок code/
- Рабочие скрипты в любых локациях
- Конфигурационные файлы (.cursorrules, .gitignore, requirements.txt)
- Защищенные области (archive_vnv_cpu_project/, docs/, data_input/, config/)

**Отличие от массовых операций:**
- Отказ от массового переноса файлов между папками
- Приоритет сохранения текущей рабочей структуры
- Более консервативный подход к реорганизации

### Защищенные области (НЕ ТРОГАТЬ)
- archive_vnv_cpu_project/ - полная защита
- code/archive/ - архивные компоненты  
- code/utils/ - рабочие утилиты
- data_input/ - входные данные
- docs/ - только 6 основных MD файлов (README.md, extract.md, transform.md, load.md, changelog.md, Tasktracker.md)
- logs/ - логи
- config/ - конфигурация

### Защита таблиц СУБД (КРИТИЧНО)
- НЕ УДАЛЯТЬ таблицы, которые НЕ созданы этим проектом
- НЕ УДАЛЯТЬ таблицы в СУБД: OlapCube_VNV, OlapCube_Analytics, Heli_Components
- ЗАПРЕЩЕНО использование DROP TABLE для внешних таблиц
- При работе с таблицами ВСЕГДА проверять что они созданы в рамках этого ETL проекта
- Словарные таблицы создаются двойными: основная + служебная для dictget ClickHouse

### Правила .gitignore:
- ВСЕГДА добавлять в .gitignore папки с библиотеками (FLAMEGPU2/, miniconda*, anaconda*)
- Исключать служебные файлы, не нужные на других компьютерах (*.whl, *.tar.gz, логи)
- Защищать конфиденциальные данные (.env.*, credentials.*, db_config.local)
- Исключать артефакты неудачных команд (=*.*.*, path==*)
- Добавлять паттерны для временных файлов разработки

Формат записи в Changelog.md: 

   ```
   markdown
   ```

   ```javascript
   ## [DD-MM-YYYY] - Краткое описание изменений
   ### Добавлено
   - Описание новых функций
   
   ### Изменено
   - Описание модификаций
   
   ### Исправлено
   - Описание исправлений
   ```

### 12. ТРЕКИНГ ЗАДАЧ И АВТОАКЦЕПТ ОПЕРАЦИЙ

#### 12.1 Правила трекинга задач (29-07-2025)
- **ЕДИНСТВЕННЫЙ ИСТОЧНИК ИСТИНЫ**: `docs/Tasktracker.md` - содержит ВСЕ задачи проекта
- **АРХИТЕКТУРА БЕЗ ЗАДАЧ**: `docs/transform.md`, `docs/extract.md`, `docs/load.md` - только архитектура и структуры данных (БЕЗ КОДА)
- **СТРОГО ЗАПРЕЩЕНО**: дублировать задачи между файлами
- **РАЗДЕЛЕНИЕ ОТВЕТСТВЕННОСТИ**: 
  * Tasktracker.md = поток задач, статусы, даты
  * transform.md/extract.md/load.md = таблицы, поля, алгоритмы (без кода)
  * changelog.md = хронология изменений

#### 12.2 Автоакцепт при уборке рабочего стола (29-07-2025)
- **ОПЕРАЦИИ ЧТЕНИЯ**: выполняются батчами БЕЗ запроса разрешений
  * find, ls, wc, grep, cat, head, tail
  * Анализ размеров файлов, структуры папок
  * Проверка содержимого файлов
  * Статистика проекта
- **ОПЕРАЦИИ ИЗМЕНЕНИЯ**: ТОЛЬКО с разрешением пользователя
  * rm, mv, cp (удаление, перемещение, копирование)
  * mkdir, rmdir (создание/удаление папок)
  * Любые изменения файловой структуры
- **ПРАВИЛО ПОЛЬЗОВАТЕЛЯ**: "ты можешь батчами уборку запускать и не спрашивать у меня команды на чтение, а только на перемещение или удаление"

### 13. Экспорт последнего чата при уборке стола
При запросе на уборку рабочего стола ОБЯЗАТЕЛЬНО:

#### 13.1 Создание экспорта чата
- Создать файл `docs/last_chat_export_DD-MM-YYYY.md` с актуальной датой
- Сохранить полную историю последнего чата с ключевыми решениями
- Включить в экспорт: задачи, проблемы, решения, изменения в коде
- Добавить ссылки на измененные файлы и разделы документации

#### 13.2 Структура экспорта чата
```markdown
# Экспорт чата от DD-MM-YYYY

## Основные темы чата
- [Краткое описание основных тем]

## Решенные задачи
- [Список выполненных задач с результатами]

## Проблемы и их решения
- [Ключевые проблемы и способы их решения]

## Изменения в коде
- [Список измененных файлов со ссылками]

## Обновления документации
- [Обновленные разделы MD файлов]

## Следующие шаги
- [Планы на будущее, незавершенные задачи]
```

#### 13.3 Интеграция с migration.md
- Обновить `docs/migration.md` при существенных изменениях архитектуры
- Добавить ссылки на экспорт чата в changelog.md
- НЕ дублировать информацию - только ссылки и краткие описания 

## Специфика FLAME GPU / pyflamegpu (добавлено 28-08-2025)
- MacroProperty и MacroPropertyArray доступны в PyFLAMEGPU. Квоты (MP6) держать в MacroPropertyArray<uint32> по дням с индексом `day+1`; атомики (`atomicSub/atomicAdd/exchange`) вызывать над `uint32_t`.
- NVRTC/Jitify: при ошибках печатать compile log; минимизировать шаблоны/сложные ветвления; строго соблюдать типы и индексацию массивов (`base = day * frames_total + idx`). Для надёжного лога использовать перенаправление `2>&1 | tee nvrtc.log` и искать `error:`.
- MP5 (daily_hours): хранить линейно размером `(days_total+1) * frames_total` с паддингом D+1 для безопасного доступа `day+1`.
- Типы: `frames_total` ≤ 300 — UInt16; сумматоры `sne/ppr` — UInt32; счётчик шага/дней (`step`, `days_total`) и «дни от эпохи» — предпочтительно UInt32 (UInt16 допустим только при горизонте < 65535).
- Порядок слоёв RTC: {6,4,2} → 3 → 5 → 1; квоту проверять до побочных эффектов; `status_id` менять не более 1 раза за сутки.
- MP2 (GPU‑логер, SoA): индекс строки `row = day * frames_total + idx`, запись батчем; чтение колонками.
- Seatbelts: dev=ON, prod=OFF; профилирование Nsight Systems — `sim.step()` должен доминировать над host.
- Инкрементальная отладка JIT: включать ровно одно RTC‑ядро за раз; при сбоях упрощать до no‑op и наращивать.