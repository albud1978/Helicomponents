# Cursor AI Rules для проекта Helicopter Component Lifecycle

Always respond in Russian

Меня зовут Алексей. Сейчас ты запущен в Cursor AI в Windows 11 под WSL в Ubuntu 22.04. 
Твоя основная задача - не только писать качественный код, но и тщательно документировать весь процесс разработки, позволяя мне отслеживать прогресс и контролировать результаты на каждом этапе.

Мы делаем проект имитационной модели оборота вертолетных агрегатов.
Данные загружаются из Excel.

## Запрещенные действия
- НЕ редактировать папку `archive_vnv_cpu_project/` - это архив CPU версии проекта
- НЕ удалять файлы из папки `archive_vnv_cpu_project/`
- НЕ создавать новые файлы в папке `archive_vnv_cpu_project/`
- НЕ удалять любые папки целиком - только отдельные файлы при необходимости

## Активная разработка ведется в папке `code/`
- Все новые изменения должны быть в папке `code/`

## Методология разработки: Анализ → Архитектура → Код
При запросах на доработки ОБЯЗАТЕЛЬНО следовать этапам:

### 1. АНАЛИЗ (сначала)
- Изучить влияние изменений на цикл ETL и связанные скрипты
- Проанализировать зависимости между компонентами системы
- Выявить потенциальные проблемы совместимости

### 2. АРХИТЕКТУРА (затем)
- Разработать проект решения с учетом ETL циклов
- Представить архитектурный план для одобрения пользователем
- Определить последовательность изменений и точки тестирования

### 3. КОД (после одобрения)
- Начинать кодирование ТОЛЬКО после одобрения архитектурного плана
- Следовать утвержденной последовательности изменений
- ВСЕГДА тестировать изменения на каждом этапе
- Запускать полный ETL пайплайн через etl_master.py для проверки совместимости
- Вносить обновления в MD файлы после успешного тестирования

### 4. СТРОГИЙ ЗАПРЕТ НА ПОДМЕНУ АЛГОРИТМОВ
- ЗАПРЕЩЕНО изменять алгоритмы расчетов без ЯВНОГО одобрения пользователя
- НЕ ПОДМЕНЯТЬ математические формулы хардкодом или упрощениями
- НЕ ИЗМЕНЯТЬ логику расчетов без предварительного анализа и согласования
- Перед любыми изменениями в алгоритмах ОБЯЗАТЕЛЬНО:
  * Представить анализ текущего алгоритма
  * Объяснить необходимость изменений
  * Получить ЯВНОЕ одобрение от пользователя
  * Показать сравнение результатов до и после изменений
- При обнаружении потенциальных проблем в алгоритмах - СООБЩИТЬ пользователю, НЕ ИСПРАВЛЯТЬ самостоятельно
- Данное правило распространяется на ВСЕ расчетные функции проекта, включая Beyond Repair, словари, ETL преобразования

### 5. ХАРДКОД И ДОКУМЕНТАЦИЯ
- ЛЮБОЙ хардкод ОБЯЗАТЕЛЬНО описывать в документации по соответствующему разделу разработки
- Документация хардкода должна включать:
  * Подробное описание логики с таблицами и полями
  * Причины использования хардкода
  * Значения констант и их обоснование
  * Планы на будущий рефакторинг
  * Примеры использования и тестовые случаи
- Хардкод может быть временным решением, но ВСЕГДА должен быть задокументирован для будущего рефакторинга

## Процесс разработки

 1. Перед началом каждого нового шага спрашивай моего подтверждения.
 2. После каждого шага предоставляй краткое резюме изменений (не более 5 пунктов).
 3. При возникновении технических проблем или неоднозначностей, предлагай 2-3 альтернативных подхода.
 4. Всегда сохраняй контекст текущей задачи и общую цель проекта.
 5. Периодически напоминай о текущем статусе задачи и оставшихся шагах.
 6. Следуй архитектурным решениям и стандартам, описанным в README.md.
 7. Соблюдай принципы SOLID, KISS, DRY.
 8. Проводи code review для всех изменений.
 9. Используйте единый стиль кодирования (линтеры, pre-commit hooks)
10. Не оставляйте неиспользуемый код и комментарии.
11. **ГОТОВНОСТЬ ЗАДАЧИ ПРИНИМАЕТ ТОЛЬКО ПОЛЬЗОВАТЕЛЬ**: НЕ меняй статус задачи на "Завершена" самостоятельно. Готовность задачи определяет и принимает только пользователь. Статус задачи изменяется на "Завершена" ТОЛЬКО после явного одобрения пользователем.

## Коммуникация

1. Если ты не уверен в требованиях или направлении разработки, задавай конкретные вопросы.
2. При предложении нескольких вариантов реализации четко объясняй преимущества и недостатки каждого.
3. Если задача кажется слишком объемной, предлагай разбить ее на подзадачи.
4. В конце каждой сессии представляй краткий отчет о достигнутом прогрессе и планах на следующую сессию.

## Ведение документации
Структура документации:
- Все MD файлы хранить в папке `docs/`
- Центральный файл: `docs/README.md` - общая информация, методы доступа к СУБД
- ETL документация: `docs/extract.md`, `docs/transform.md`, `docs/load.md`, `docs/changelog.md`
- Управление задачами: `docs/Tasktracker.md` - статус выполнения задач с описанием
- Changelog.md - хронологический журнал всех изменений
- Все остальные документы присоединить к указанным выше
- В каждом документе указывать: перечень скриптов, порядок работы, логику преобразований таблиц
- ОБЯЗАТЕЛЬНО указывать имена таблиц и полей в СУБД
- Код в MD не писать, кроме случаев когда иначе невозможно объяснить логику

## Правила датирования в документации
- При обновлении документации ВСЕГДА использовать АКТУАЛЬНУЮ системную дату
- НЕ ИСПОЛЬЗОВАТЬ фиксированные даты типа "19-07-2025" 
- Получать дату через команду `date` или системные функции
- Формат даты в changelog: `## [DD-MM-YYYY]` где DD-MM-YYYY - текущая системная дата
- Формат даты в комментариях кода: `Дата: YYYY-MM-DD` (текущая дата)
- При создании новых записей в Tasktracker указывать актуальную дату завершения
- При обновлении статуса задач обновлять временные метки на текущую дату

## Содержание MD файлов
- Писать ТОЛЬКО факты или то, что согласовано с пользователем
- НЕ придумывать несуществующие компоненты, скрипты или функции
- Описывать только реально существующий код и процессы
- Указывать актуальные названия скриптов, таблиц и полей
- На каждом этапе указывать какие поля в каких таблицах изменяются

При любых изменениях в проекте сначала актуализируй документацию, а затем приступай к следующему шагу разработки. Это позволит избежать потери контекста и обеспечит более последовательный и контролируемый процесс разработки.

## Автоматическая уборка рабочего стола
При запросе на уборку выполнять:

### 1. Очистка временных файлов
- Все папки __pycache__ и файлы *.pyc
- Логи старше 7 дней в logs/
- Файлы *.tmp, *.backup, *.bak

### 2. Очистка отладочных файлов
- Файлы *test*, *debug*, *check*, *analyze* в корне проекта
- НЕ трогать code/archive/ и code/utils/analysis/

### 3. Очистка дублей и копий
- Файлы *_OLD*, *_old*, *_backup*, *_bak*, copy_*, *_copy*
- Дублирующие конфигурационные файлы

### 4. Очистка мусорных файлов от неудачных команд
- Файлы вида "=X.X.X" (результат pip install ошибок)
- Временные файлы загрузки (*.whl в корне после установки)
- Файлы .download, .temp, .cache в корне проекта

### 5. Уборка корня проекта
ТОЛЬКО мусорные файлы, НЕ ТРОГАТЬ текущие рабочие файлы:

#### Очистка мусора в корне:
- Артефакты неудачных команд (=*.*.*, path==*, *==*.*.*)
- Временные файлы установки (*.whl, *.tar.gz, *.zip в корне)
- Логи и кэши (.log, .tmp, .cache, .download в корне)
- Файлы резервных копий (*.backup, *.bak, *_backup в корне)

#### ЗАЩИЩЕННЫЕ файлы в корне (НЕ УДАЛЯТЬ):
- .cursorrules, .gitignore, requirements.txt (конфигурация)
- Файлы документации корневого уровня (если есть)
- Рабочие скрипты (должны быть перенесены в code/, но НЕ удалены)

### 6. Анализ и реорганизация
ПЕРЕД ПЕРЕНОСОМ СПРАШИВАТЬ РАЗРЕШЕНИЯ:

#### Утилиты из корня → code/utils/
- Разовые скрипты очистки СУБД
- Тестовые скрипты НЕ являющиеся частью ETL

#### Скрипты конфигурации → config/
- load_env.sh → config/
- Скрипты настройки окружения

#### В code/ должны остаться ВСЕ ETL скрипты
- Загрузчики (*_loader.py)
- Процессоры статусов (*_processor.py) 
- Обогащение данных (*_enricher.py, *_creator.py)
- etl_master.py (оркестратор)
- dual_loader.py (основной загрузчик)
- calculate_beyond_repair.py (расчеты для ETL)

#### Утилиты = только разовые/вспомогательные
- Тесты подключений
- Очистка СУБД
- Диагностика (НЕ часть основного ETL)
- Утилиты-обертки для удобного ручного запуска (create_all_dictionaries.py)

### 7. Защищенные области (НЕ ТРОГАТЬ)
- archive_vnv_cpu_project/ - полная защита
- code/archive/ - архивные компоненты
- code/utils/ - рабочие утилиты
- data_input/ - входные данные
- docs/ - только 6 основных MD файлов (README.md, extract.md, transform.md, load.md, changelog.md, Tasktracker.md)
- logs/ - логи
- config/ - конфигурация

Формат записи в Changelog.md: 

   ```
   markdown
   ```

   ```javascript
   ## [DD-MM-YYYY] - Краткое описание изменений
   ### Добавлено
   - Описание новых функций
   
   ### Изменено
   - Описание модификаций
   
   ### Исправлено
   - Описание исправлений
   ```

### 8. Защита таблиц СУБД (КРИТИЧНО)
- НЕ УДАЛЯТЬ таблицы, которые НЕ созданы этим проектом
- НЕ УДАЛЯТЬ таблицы в СУБД: OlapCube_VNV, OlapCube_Analytics, Heli_Components
- ЗАПРЕЩЕНО использование DROP TABLE для внешних таблиц
- При работе с таблицами ВСЕГДА проверять что они созданы в рамках этого ETL проекта
- Словарные таблицы создаются двойными: основная + служебная для dictget ClickHouse

### 9. Содержание корня проекта (ВАЖНО)
НЕ ЗАСОРЯТЬ корень проекта, кроме того что уже было создано:

#### Разрешенные файлы в корне:
- .cursorrules, .gitignore, requirements.txt (конфигурация)
- Файлы документации корневого уровня (если есть)

#### ЗАПРЕЩЕНО создавать в корне:
- Временные файлы установки (*.whl, *.tar.gz)
- Мусорные файлы команд (=X.X.X, path==X.X.X)
- Тестовые скрипты (.py файлы - должны быть в code/)
- Логи и временные данные (.log, .tmp, .cache)
- Скрипты конфигурации (должны быть в config/)
- Любые рабочие файлы (должны быть в соответствующих папках)

#### При обнаружении мусора:
- ВСЕГДА очищать временные файлы после установки
- Перемещать скрипты в подходящие папки (code/, config/, docs/)
- НЕ оставлять артефакты неудачных команд
- Обновлять .gitignore для исключения новых типов мусорных файлов

#### Правила .gitignore:
- ВСЕГДА добавлять в .gitignore папки с библиотеками (FLAMEGPU2/, miniconda*, anaconda*)
- Исключать служебные файлы, не нужные на других компьютерах (*.whl, *.tar.gz, логи)
- Защищать конфиденциальные данные (.env.*, credentials.*, db_config.local)
- Исключать артефакты неудачных команд (=*.*.*, path==*)
- Добавлять паттерны для временных файлов разработки

### 10. Анализ кода папки code/ на устаревшие скрипты
ПЕРЕД ПЕРЕНОСОМ СПРАШИВАТЬ РАЗРЕШЕНИЯ:

#### Критерии для анализа code/:
- Проверить участие скрипта в ETL_PIPELINE (etl_master.py)
- Проверить импорты в основных ETL скриптах (dual_loader.py и др.)
- Классифицировать: ETL / Утилита / Устаревший
- Проверить статус интеграции новых скриптов (flight_program_fl_loader.py)

#### Устаревшие скрипты → code/archive/
- Скрипты функциональность которых интегрирована в другие
- НЕ УДАЛЯТЬ - только переносить в архив
- Пример: aircraft_number_dict_creator.py → интегрирован в dictionary_creator.py

#### Утилиты-обертки → code/utils/
- Скрипты для удобного ручного запуска функций ETL
- НЕ участвуют в автоматическом ETL пайплайне
- Пример: create_all_dictionaries.py (обертка для dictionary_creator.py)

#### НЕ интегрированные ETL скрипты:
- Скрипты готовые к работе, но НЕ добавленные в etl_master.py
- Требуют интеграции в автоматический ETL пайплайн
- НЕ перемещать - фиксировать необходимость интеграции
- Пример: flight_program_fl_loader.py (создан, но не в ETL_PIPELINE)

### 11. Логика переноса
- ВСЕГДА спрашивать разрешение перед переносом файлов
- Обновлять импорты в скриптах после переноса  
- Тестировать ETL после реорганизации
- Сохранять функциональность системы
- НЕ УДАЛЯТЬ скрипты - только переносить в подходящие папки 