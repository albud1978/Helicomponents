# Правила проекта (консолидировано)

- Всегда отвечать на русском языке.
- Рабочая разработка — в `code/`. Архив `archive_vnv_cpu_project/` не трогать.
- Запрещено создавать фейковые файлы/результаты и использовать хардкод (кроме лок. отладки с тестами и фиксацией).
- Минимальный дифф по умолчанию: ≤3 файлов, ≤150 строк, 1 подсистема, без новых публичных API.
- Любые изменения архитектуры/алгоритмов/схем данных — только после явного согласования в чате.

## Данные и типы
- В СУБД избегать Float64 без согласования. Предпочтать: UInt8/16/32 и Float32.
- MP5 (суточные минуты) — хранить в `UInt16/UInt32` в Env (в соответствии с источником).
- Тесты/прогоны выполнять ТОЛЬКО на реальных данных из ClickHouse. Синтетика/заглушки — только с явным разрешением Алексея в текущем чате.

## Transform / RTC инварианты (v3 - state-based, 22.12.2024)
- Один процесс: единый `ModelDescription` + `CUDASimulation`, без перезагрузки `env` между шагами.
- FRAMES = |MP3 ∪ MP5| (без расширения «впрок»). Индексы для будущих бортов берутся из объединения.
- **Фильтрация планеров**: Из ~7113 строк MP3 агентами становятся только планеры с group_by ∈ {1,2} (~286 бортов).
- MP5 держать в `MacroProperty mp5_lin[MAX_SIZE]` с фиксированным MAX_SIZE; инициализация ТОЛЬКО через HostFunction до первых RTC.
- Запрет записи в `mp5_lin` после начала чтения агентами. RTC копирование запрещено.
- Размеры MacroProperty: MAX_FRAMES определяется из данных MP3/MP5, MAX_DAYS=4000, MAX_SIZE=MAX_FRAMES*(MAX_DAYS+1).
- **OH при создании**: Значения oh (overhaul hours) определять при создании агентов из MP1 по group_by, НЕ в RTC. OH в MP1 уже хранится в минутах, умножать на 60 НЕ НАДО!
  - Использовать `mp1_index` для получения индекса: `pidx = mp1_index.get(partseqno, -1)`
  - Для Mi-8 (group_by=1): брать из `mp1_oh_mi8[pidx]`
  - Для Mi-17 (group_by=2): брать из `mp1_oh_mi17[pidx]`
- **Assembly trigger при создании**: Для агентов в статусе 4 проверять `repair_time - repair_days > assembly_time` и устанавливать `assembly_trigger = 1` если условие выполнено.
- **State-based архитектура**: Использовать FLAME GPU States вместо переменной status_id.
- **Отдельные RTC функции**: Каждое состояние имеет свою RTC функцию для модульности.
- **Разделение логики**: RTC функции состояний НЕ меняют state, только устанавливают intent флаги.
- **Централизованное квотирование**: Единый менеджер квот с приоритетами без атомарных операций.
- **Атомарные переходы**: Все смены состояний в единой RTC функции `rtc_state_transitions`.
- **КРИТИЧНО: Порядок слоёв (layers)**: Модули ДОЛЖНЫ выполняться в строгом порядке согласно матрице состояний (`data_input/analytics/state-intent matrix.xlsx`). См. детали в `docs/rtc_pipeline_architecture.md`.

## Тестирование и валидации (обновлено 13.10.2025)

### Приоритет валидации
- **Основной контроль**: Итоговая выгрузка в СУБД через MP2 (device-side export).
- **Логирование в RTC коде**: Добавляется ТОЛЬКО по явному согласованию Алексея в текущем чате.
- **Удаление логов**: После успешного устранения проблемы код логирования УДАЛЯЕТСЯ + повторное тестирование.
- **Критерий успеха**: Тест считается успешным только при подтверждении результатов в СУБД БЕЗ избыточного логирования.

### Риски логирования в CUDA ядрах
При добавлении `printf` или других операций логирования в RTC ядра учитывать:
- Race conditions (конкурентная запись в stdout от тысяч потоков)
- Потенциальные сбои компиляции NVRTC
- Ограничения FLAME GPU на вывод из device-side кода
- Производительность (логирование может замедлить симуляцию в десятки раз)

### Матрица тестов
- DAYS={5,90,365,3650}. Детерминизм повторных прогонов на одном снапшоте.
- Для валидации модулей: полный прогон на 3650 дней (все ядра скомпилированы).

### Инварианты
- S6 неизменяем, Δsne_s2 == sum(dt_s2), корректный D+1 паддинг MP5.
- Все проверки инвариантов выполняются SQL-запросами к СУБД.

## Документация и процесс
- Перед правками — анализ влияния на ETL/скрипты; после — обновление MD только при зелёных тестах.
- **Обязательное ведение**: 4 основных документа при любых изменениях:
  1. `docs/validation.md` — инварианты, тесты, багфиксы
  2. `docs/changelog.md` — история изменений с датами
  3. `docs/rtc_pipeline_architecture.md` — архитектура модулей и принципы
  4. `docs/README.md` — команды запуска, связи документов
- **Связи в документации**: README.md ↔ validation.md ↔ changelog.md ↔ rtc_pipeline_architecture.md ↔ .cursorrules (этот файл).
- **Команда "обновить документацию"**: проверить и обновить все 4 основных файла.
- Обновлять `docs/rtc_pipeline_architecture.md` при изменении оркестрации/ядер/архитектурных принципов.
- Обновлять `docs/validation.md` при изменении проверок, добавлении модулей или обнаружении багов.
- Обновлять `docs/changelog.md` при ЛЮБЫХ изменениях кода (багфиксы, улучшения, рефакторинг).
- Хранить этот файл правил как источник истины.

## Экспертный уровень анализа и разработки (обновлено 19.10.2025)

### Требуемый уровень работы
- **Вы ведущий мировой эксперт по разработке ПО**. Требуется экспертный уровень анализа во всех задачах.
- **Глубокое понимание логики систем**: Перед любым выводом полностью изучить архитектуру, инварианты, граничные условия.
- **Проверка предположений**: Не делать поверхностных выводов. Тщательно анализировать возможные состояния системы.
- **Отказ от шаблонного мышления**: Каждая система имеет уникальную логику — не применять стандартные решения без обоснования.

### Правила диагностики
- **Ошибки диагностики недопустимы**. Если обнаружена собственная ошибка — немедленно её признать, исправить и внести урок.

### Процесс анализа
1. **Читать полный контекст** — архитектурные документы, исходный код, инварианты.
2. **Определить ключевые предположения** — что ОБЯЗАТЕЛЬНО должно быть верно.
3. **Проверить граничные случаи** — нулевые значения, экстремальные ситуации, конфликты.
4. **Перепроверить логику** — особенно для систем с взаимодействиями (квотирование, состояния, переходы).
5. **Скептичный взгляд** — предположить наихудший сценарий для собственного решения.

### Признание ошибок
- При обнаружении ошибки в собственной диагностике: полное признание, исправление, объяснение урока.
- Каждая ошибка — улучшение процесса анализа для будущих задач.
- Примечание: правило добавлено 19.10.2025 после неправильного анализа deficit расчёта в P1.

## Команда запуска симуляции (обновлено 16.11.2025)

**ПРАВИЛЬНЫЙ порядок модулей (КРИТИЧНО!):**

```bash
cd "/home/budnik_an/cube linux/cube" && \
source config/load_env.sh && \
export CUDA_PATH=/usr/local/cuda && \
export CUBE_CONFIG_PATH="/home/budnik_an/cube linux/cube/config" && \
cd code/sim_v2 && \
python3 orchestrator_v2.py --modules \
  state_2_operations \
  states_stub \
  count_ops \
  quota_ops_excess \
  quota_promote_serviceable \
  quota_promote_reserve \
  quota_promote_inactive \
  spawn_dynamic \
  state_manager_serviceable \
  state_manager_operations \
  state_manager_repair \
  state_manager_storage \
  state_manager_reserve \
  state_manager_inactive \
  spawn_v2 \
  --steps 3650 --enable-mp2 --drop-table
```

**Ключевые правила порядка:**
1. `spawn_v2` ВСЕГДА в конце (новые агенты проходят логику на следующем шаге)
2. `state_manager_serviceable` ПЕРЕД `state_manager_operations` (холдинг до промоута)
3. Порядок state_manager: serviceable → operations → repair → storage → reserve → inactive

**Источник:** Матрица состояний `data_input/analytics/state-intent matrix.xlsx`  
**Детали:** `docs/rtc_pipeline_architecture.md` (секция "Порядок слоёв")

