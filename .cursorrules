# Cursor AI Rules для проекта Helicopter Component Lifecycle

Always respond in Russian

Меня зовут Алексей. Ты запущен в Cursor AI на Windows 11 под WSL (Ubuntu 22.04).
Твоя задача — писать качественный код и строго документировать процесс так,
чтобы можно было отслеживать прогресс и контролировать результат на каждом шаге.

Мы делаем имитационную модель оборота вертолётных агрегатов.
Данные исходно загружаются из Excel.

──────────────────────────────────────────────────────────────────────────────
## 0. Режим работы ИИ: активный соавтор, но по согласованному плану
- ИИ ПРОАКТИВЕН: вправе предлагать архитектурные/алгоритмические улучшения,
  указывать на долги и риски.
- НО ЛЮБЫЕ СУЩЕСТВЕННЫЕ ИЗМЕНЕНИЯ (архитектура, алгоритмы, схемы данных,
  публичные API, файловая структура) ДЕЛАЮТСЯ ТОЛЬКО ПОСЛЕ ЯВНОГО СОГЛАСОВАНИЯ
  с пользователем (Алексеем) в текущем чате.
- После согласования общей архитектуры/плана ИИ действует самостоятельно
  по шагам плана без запроса подтверждения на каждый подшаг.

──────────────────────────────────────────────────────────────────────────────
## 1. Запрещённые действия
- НЕ редактировать, НЕ удалять и НЕ создавать файлы в `archive_vnv_cpu_project/`
  (архив CPU-версии). Любые изменения там запрещены.
- НЕ удалять целые папки; допускается удаление отдельных файлов ТОЛЬКО после
  явного подтверждения пользователем в чате.
- **СТРОГО ЗАПРЕЩЕНО** создавать фейковые файлы и фейковые результаты.
- **ЗАПРЕЩЁН хардкод** без разрешения (кроме локальной отладки с обязательными
  тестами и документированием).
- **Уточнение по удалению объектов**:
  удаление любых объектов проекта (файлы/каталоги, таблицы/представления в СУБД,
  документы в `docs/`) — ТОЛЬКО после прямого подтверждения в текущем чате.

──────────────────────────────────────────────────────────────────────────────
## 2. Где вести разработку
- Вся активная разработка — в папке `code/`. Новые изменения и файлы — там.

──────────────────────────────────────────────────────────────────────────────
## 3. Методология: АНАЛИЗ → АРХИТЕКТУРА → КОД → ВАЛИДАЦИЯ
**3.1 АНАЛИЗ (всегда сначала)**
- Оценить влияние изменений на ETL-цепочку и связанные скрипты.
- Построить краткую карту зависимостей (затронутые модули/данные).
- Определить потенциальные несовместимости и риски.

**3.2 АРХИТЕКТУРА (после анализа)**
- Сформировать архитектурный план (пошагово, 3–7 пунктов) с точками тестирования.
- Получить от пользователя явное одобрение плана перед началом кодирования.

**3.3 КОД (после одобрения плана)**
- Реализовывать строго по согласованным шагам.
- На каждом шаге — локальные тесты и минимальный дифф (см. §6).

**3.4 ВАЛИДАЦИЯ**
- Прогон полного пайплайна через скрипт-оркестратор после завершения шага,
  если шаг влияет на данные или схемы.
- Обновлять документацию (MD) только после зелёных тестов.

──────────────────────────────────────────────────────────────────────────────
## 4. Запрет на подмену алгоритмов и поверхностные «фиксы»
- **ЗАПРЕЩЕНО** менять расчёты, подменять формулы упрощениями или хардкодом
  без явного согласования с пользователем.
- Любые изменения алгоритмов требуют:
  1) анализа текущего алгоритма и причины изменения,
  2) демонстрации выигрыша/влияния,
  3) явного согласия пользователя,
  4) сравнения результатов ДО/ПОСЛЕ на реальных данных.

──────────────────────────────────────────────────────────────────────────────
## 5. Типы данных и критичность ошибок
- **ЗАПРЕЩЕНО** использовать Float64 в СУБД без явного согласования.
- При сомнениях в типе — спрашивать пользователя. Приоритеты:
  - `UInt8` — флаги/малые счётчики;
  - `UInt16` — средние значения/ID;
  - `UInt32` — большие значения/PK/сумматоры;
  - `Float32` — денежные/расчётные (вместо Float64);
  - `String` — только текст.
- Перед использованием Float64: обосновать точность, получить согласование,
  рассмотреть альтернативы (`UInt32`, `Float32`).
- **КРИТИЧНОСТЬ ОШИБОК**: Любая ошибка в любом пайплайне критична и
  требует устранения причины (никаких «continue on error»).
- Это распространяется на все расчётные функции.

**5.1 Назначение типов для новых данных (по источнику)**
- Типы в GPU-Env задавать от типов источника (ClickHouse/Excel) и фактических
  диапазонов. Любое отклонение — с обоснованием и фиксацией в `docs/changelog.md`
  (таблица/поле, исходный тип, целевой тип, min/max, причина: память/скорость/
  NVRTC, влияние на RTC, ссылки на тесты).
- Чек-лист перед изменением типа:
  1) Таблица/поле-источник и исходный тип,
  2) Предлагаемый целевой тип в Env,
  3) Диапазон значений (min/max, кардинальность),
  4) Причины выбора (GPU, экономия, точность, NVRTC),
  5) Ссылки на прогоны/инварианты.
- MP5.daily_hours: источник — целочисленные минуты; в Env хранить `UInt16`.
  Запрещено повышать до `UInt32` без обоснования и подтверждённых тестов, кроме случаев обеспечения совместимости при вычислениях.

**5.2 Никаких «неважных этапов» и «тихих пропусков» (05-09-2025)**
- Каждый этап пайплайна важен; деградация функциональности при ошибках запрещена.
- При появлении новой зависимости:
  - либо явная перестановка этапов по согласованию,
  - либо новый завершающий обогащающий этап, не ломающий текущую логику.
- Любая ошибка этапа — остановка пайплайна и устранение причины.

──────────────────────────────────────────────────────────────────────────────
## 6. Анти-избыточность и минимальный дифф (vibe-coding guardrails)
**Цель** — пресечь наслоения «бесполезных доработок»:
- Генерируй ТОЛЬКО код, решающий текущую задачу. Никаких «на будущее».
- Запрещены избыточные заготовки, универсальные «мегаутилии», дубли логики.
- Любой добавленный код должен быть либо вызван, либо удалён до конца задачи.
- **Политика минимального диффа (по умолчанию):**
  - изменённых файлов ≤ 3,
  - суммарный дифф ≤ 150 строк,
  - 0 новых публичных API (кроме заранее согласованных),
  - зона изменений локализована в 1 подсистеме.
  (Если объективно нужно больше — запрашивается разовое повышение лимитов с
  обоснованием и подтверждением в чате.)
- **Удаления/массовые перемещения** — только по подтверждённому плану (см. §1).

──────────────────────────────────────────────────────────────────────────────
## 7. Тестирование: characterization + дельта‑покрытие
- Перед правкой сложного/лавинно-связанного участка — создать characterization
  (golden master) тесты, фиксирующие текущее поведение.
- Любой баг превращается в тест, воспроизводящий дефект.
- Требование по покрытию **дельты изменений**: ≥ 80% строк/ветвей в изменённой
  области (если ниже — дать обоснование и план доведения).
- После правок — полный прогон релевантных тестов и `extract_master.py`.

──────────────────────────────────────────────────────────────────────────────
## 8. Синхронные изменения логики TRANSFORM/RTC 
- **КРИТИЧНО**: все изменения симуляции и RTC-функций — только синхронно
  с пользователем.
- **ЗАПРЕЩЕНО** самостоятельно менять:
  - алгоритмы балансировки агентов;
  - условия триггеров RTC;
  - логику переходов статусов;
  - формулы `sne`, `ppr`, `repair_days`.
- **ОБЯЗАТЕЛЬНА СИНХРОНИЗАЦИЯ**:
  - любые изменения JSON-конфигов RTC;
  - модификация архитектуры симуляций;
  - корректировки условий spawn/balance;
  - изменения MacroProperty/структур.
- **Процедура**: остановись → опиши суть → дождись одобрения → только потом правь.
- **Исключение**: техническая отладка (с обязательным уведомлением пользователя).

──────────────────────────────────────────────────────────────────────────────
## 9. Хардкод и заглушки
- Любой хардкод документировать: логика, таблицы/поля, причины, значения,
  план рефакторинга, примеры и тесты.
- Заглушки/dummy/mock — только с явным предупреждением. Запрещены имитации
  технологий (например, Python вместо настоящего FLAME GPU/C++/CUDA).
- Временная отладка допускается при:
  - явном предупреждении,
  - переносе кода в правильные папки после отладки,
  - тестировании на реальных данных,
  - удалении временных файлов,
  - записи в changelog.

──────────────────────────────────────────────────────────────────────────────
## 10. Управление памятью правил
- Фиксировать в памяти системные ошибки, неудачные решения и уроки.
- После `update_memory` спрашивать: «Нужно ли отразить изменения в .cursorrules?».
- При подтверждении — обновлять `.cursorrules`.
- Перед крупной задачей сверять память и `.cursorrules`.

──────────────────────────────────────────────────────────────────────────────
## 11. Процесс разработки (рабочие привычки)
1) Не запрашивай подтверждение перед каждым подшагом — следуй согласованному плану.
2) После каждого шага — краткое резюме (≤5 пунктов).
3) При неоднозначностях — 2–3 альтернативы с плюсами/минусами.
4) Держи контекст задачи и общую цель.
5) Периодически напоминай статус и оставшиеся шаги.
6) Соблюдай стандарты из README.md и принципы SOLID/KISS/DRY.
7) Code review — обязателен перед крупной интеграцией.
8) Единый стиль: линтеры, pre-commit hooks.
9) Не оставляй мёртвый код и пустые комментарии.
10) **Тестирование обязательно** на реальных данных перед передачей результата.
11) **Запрет на фейки**: никаких вымышленных функций/данных/имитаций без разрешения.
12) Перед кодом — изучи `docs/` (архитектура, этапы, зависимости).

──────────────────────────────────────────────────────────────────────────────
## 12. Коммуникация
- При неясности требований — задавай точные вопросы.
- Предлагая варианты — объясняй преимущества/компромиссы/риски.
- Слишком крупную задачу — дроби на подзадачи и согласуй.
- В конце сессии — короткий отчёт: что сделано, что дальше.

──────────────────────────────────────────────────────────────────────────────
## 13. Документация
- Все MD — в `docs/`. Центр: `docs/README.md`.
- ETL: `docs/extract.md`, `docs/transform.md`, `docs/load.md`, `docs/changelog.md`, `rtc_pipeline_architecture.md`, `validation.md`, `migration.md`
- Трекинг задач: `docs/Tasktracker.md` — единственный источник истины по задачам.
- Документы должны перечислять скрипты, порядок работы, преобразования таблиц,
  имена таблиц и полей в СУБД.
- Код в MD — только если иначе нельзя объяснить логику.
- **Запрет на удаление таблиц/столбцов в документации** без явного разрешения.
  Разрешены изменения содержимого и добавление строк; структурные правки —
  только по согласованию (с обоснованием).
- При существенных архитектурных изменениях обновлять `docs/migration.md`
  и делать ссылку в `changelog.md` (без дублирования контента).

**13.1 Правила датирования**
- В документации использовать актуальную системную дату (не фиксированные даты).
- Формат changelog: `## [DD-MM-YYYY]`.
- В комментариях кода: `Дата: YYYY-MM-DD`.
- В Tasktracker — актуальные даты статусов.

──────────────────────────────────────────────────────────────────────────────
## 14. Автоматическая уборка рабочего стола (безопасный режим)
**Принципы:** агентный анализ, целевая очистка, без реорганизации структуры.
**Очищаем автоматически:** `__pycache__`, `*.pyc`, логи > 7 дней (`logs/`),
`*.tmp`, `*.backup`, `*.bak`, дубли `*_backup`, `*_copy`, артефакты неудачных
команд (`=*.*.*`, `path==*`, `*==*.*.*`), временные пакеты в корне
(`*.whl`, `*.tar.gz`, `*.zip`), `.log/.tmp/.cache/.download` в корне.
**НЕ трогаем:** структуру `code/`, рабочие скрипты, `.cursorrules`, `.gitignore`,
`requirements.txt`, `archive_vnv_cpu_project/`, `docs/`, `data_input/`, `config/`.
**Чтение без подтверждения:** `find/ls/wc/grep/cat/head/tail` и аналитика.
**Любые изменения (rm/mv/cp/mkdir/rmdir)** — ТОЛЬКО с разрешения пользователя.

**Защищённые области (НЕ ТРОГАТЬ)**
- `archive_vnv_cpu_project/` — полная защита
- `code/archive/`, `code/utils/`, `code/sim/`, `code/rtc/`
- `data_input/`, `docs/`, `logs/`, `config/`, code/

──────────────────────────────────────────────────────────────────────────────
## 15. СУБД: защита и правила
- НЕ удалять таблицы, не созданные этим проектом.
- Запрещён `DROP TABLE` для внешних таблиц.
- Проверять, что таблицы действительно относятся к этому ETL.
- Словари — двойные: основная + служебная (для `dictget` ClickHouse).

──────────────────────────────────────────────────────────────────────────────
## 16. .gitignore
- Игнорировать каталоги библиотек (`FLAMEGPU2/`, `miniconda*`, `anaconda*`).
- Исключать артефакты сборки/логов (`*.whl`, `*.tar.gz`, логи).
- Защищать секреты (`.env.*`, `credentials.*`, `db_config.local`).
- Исключать артефакты неудачных команд (`=*.*.*`, `path==*`).
- Добавлять паттерны временных файлов разработки.

**Шаблон записи в `docs/changelog.md`:**
```javascript
## [DD-MM-YYYY] - Краткое описание изменений
### Добавлено
- ...

### Изменено
- ...

### Исправлено
- ...
