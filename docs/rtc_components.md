# RTC Components Architecture (Агрегаты)

**Дата:** 31.10.2025  
**Версия:** 0.2 (обновлено: интеграция sne_new/ppr_new из MP1)

## 0. Текущее состояние и приоритеты

- Постпроцессинг ETL, который мы сейчас выполняем (`status_overhaul`, `program_ac`, `inactive_planery_processor`, Program_AC / Program_FL загрузчики), затрагивает **только планеры** (`group_by ∈ {1,2}`).  
  - Эти шаги нужны, чтобы симуляция планеров имела корректные `status_id`, `aircraft_number`, `flight_program` и квоты.  
  - На агрегаты (`group_by ≥ 3`) они не распространяются: статус остаётся `0`, `aircraft_number` — 0, программ налёта нет.
- Для агрегатов корневым источником потребности остаётся планерная симуляция: MP2 выдаёт налёт, ремонтные события и `assembly_trigger`, которые определяют, какие агрегаты нужны/выбывают. Поэтому отдельные MP под агрегаты (аналог MP4/MP5 у планеров) не требуются — мы будем использовать MP2 как источник «команд» на комплектацию.
- Цель ближайших итераций — **поэтапно заполнить `status_id` для агрегатов** так, чтобы в массиве не оставалось нулевых значений. Логика распределения статусов будет опираться на данные MP2 (состояние планера, триггеры замены) и станет частью архитектуры, описанной ниже.
- Этот документ — дизайн-проект RTC для агрегатов. Реализация ещё не завершена; текст ниже фиксирует договорённости по переменным, источникам данных и плану spawn/статусов.

---

## 1. ПЕРЕМЕННЫЕ АГЕНТОВ

### Агрегаты (Agent "unit")

| Категория | Переменные | Δ от планеров |
|-----------|------------|---------------|
| **States** | operations, serviceable, repair, reserve, storage | -inactive |
| **ID** | idx, **psn**, aircraft_number, partseqno_i, group_by | +psn (PRIMARY KEY) |
| **Наработка** | sne, ppr | -cso |
| **Нормативы** | ll, oh, br | = |
| **Ремонт** | repair_time, repair_days | -assembly_time, -partout_time |
| **Триггеры** | — | -assembly_trigger, -active_trigger, -partout_trigger, -s4_days |
| **MP2 планера** | dt, dn | читаются из mp2_dt/mp2_dn по aircraft_number |
| **Квоты** | intent_state, mfg_date | = |
| **Transitions** | transition_2_to_3, transition_2_to_4, transition_2_to_6, transition_3_to_2, transition_4_to_5, transition_5_to_2 | -transition_1_to_2, -transition_1_to_4, -transition_4_to_2 |
| **Служебное** | bi_counter | = |

**Итого:** 23 переменных (vs 33 у планеров)

**Важно:** 
- State `inactive` у агрегатов НЕ используется (новые агрегаты создаются в `reserve`)
- Transition `1→2` НЕ нужен (нет inactive state)
- Spawn агрегатов идёт сразу в `reserve` (готов к установке на планер)

---

## 2. ИСТОЧНИКИ ИНИЦИАЛИЗАЦИИ

### Таблица источников данных при создании агентов

| Переменная | Источник (MP3) | Логика инициализации (существующие) | Логика spawn (новые inactive) |
|------------|----------------|-------------------------------------|-------------------------------|
| **idx** | Плотный индекс | Начинается с (last_idx_планеров + 1), сортировка по mfg_date внутри group_by | Зарезервированный idx в конце группы |
| **psn** | MP3.psn | PRIMARY KEY агрегата, уникальный идентификатор | Сегмент: 2000000 + (group_by × 100000) + counter |
| **aircraft_number** | MP3.aircraft_number | Номер планера-родителя (0 если в пуле) | 0 (в пуле до установки) |
| **partseqno_i** | MP3.partseqno_i | Код типа агрегата из справочника | Выбор по логике (см. раздел 5.5) |
| **group_by** | MP3.group_by | Тип агрегата (3=Двг Ми-8, 4=Двг Ми-17) | Константа: 3 или 4 |
| **sne** | MP3.sne | Наработка с начала эксплуатации (минуты) | MP1.sne_new[partseqno_i] (NULL→0) |
| **ppr** | MP3.ppr | Наработка после последнего капремонта | MP1.ppr_new[partseqno_i] (NULL→0) |
| **ll** | MP3.ll или MP1 | Если MP3.ll > 0 → MP3, иначе MP1 по group_by | MP1 по group_by |
| **oh** | MP1 | По partseqno_i через mp1_index | MP1 по group_by |
| **br** | MP1 | По partseqno_i через mp1_index | MP1 по group_by |
| **repair_time** | MP1 | mp1_repair_time[pidx] | MP1 по group_by |
| **repair_days** | MP3.repair_days | Счетчик дней в ремонте | 0 (новый агрегат) |
| **intent_state** | Константа | 0 (без намерений) | 0 (без намерений) |
| **mfg_date** | MP3.mfg_date | Дата производства (дни с эпохи) | 0 (установится при установке на планер) |
| **dt, dn** | MP2 | Чтение по aircraft_number из mp2_dt/mp2_dn планера | 0 (aircraft_number=0) |
| **bi_counter** | Константа | 1 (для BI) | 1 (для BI) |
| **transition_*** | Константы | 0 (без переходов) | 0 (без переходов) |
| **state** | MP3.status_id | Маппинг status_id → state | reserve (готов к установке) |

**Особенности:**
- Фильтрация: из ~7113 строк MP3 берутся только записи с `group_by ∈ {3,4}` (сначала 3, потом 4; остальные группы добавятся позже)
- **Уникальность: один агент = один `psn` (PRIMARY KEY), не aircraft_number**
  - ⚠️ **ВАЖНО:** У планеров (group_by=1,2) переменной `psn` НЕТ! Используется только `aircraft_number`
  - У агрегатов (group_by≥3) `psn` — обязательное поле (PRIMARY KEY в СУБД)
- Связь с планером: через `aircraft_number` (0 = в пуле, >0 = на конкретном планере)
- Индексация: плотный индекс начинается после последнего idx планеров, последовательно: сначала все group_by=3, затем все group_by=4
- Сортировка: по mfg_date (от старых к новым) внутри каждой group_by
- **Spawn-резерв:** слоты в конце каждой группы резервируются на этапе инициализации
  - Резервные слоты рассчитываются по формуле выработки ресурса (раздел 5.4)
  - При инициализации заполняются **только `idx` и `psn`** (по формуле сегментирования)
  - Остальные переменные **НЕ заполняются** до момента реального spawn
  - Реальный spawn происходит динамически при дефиците в пуле (раздел 5.3)

---

---

## 3. АНАЛИЗ ДИАПАЗОНОВ PSN

### Текущие диапазоны в heli_pandas (обновлено 30.10.2025)

| group_by | Тип | Всего | Уник.PSN | MIN(psn) | MAX(psn) |
|----------|-----|-------|----------|----------|----------|
| 1 | Планеры Ми-8 | 163 | 163 | 148724 | 922207 |
| 2 | Планеры Ми-17 | 116 | 116 | 148717 | 1459322 |
| **3** | **Двг Ми-8** | **520** | **520** | **2702** | **1606586** |
| **4** | **Двг Ми-17** | **384** | **384** | **2760** | **1519814** |
| 5 | Агрегат | 264 | 264 | 2715 | 1543914 |
| 6 | Агрегат | 1588 | 1588 | 6557 | 1612576 |
| 7 | Агрегат | 248 | 248 | 2934 | 1521154 |
| 8 | Агрегат | 287 | 287 | 2778 | 1521178 |
| 9 | Агрегат | 275 | 275 | 2716 | 1521182 |
| 10 | Агрегат | 249 | 249 | 2777 | 1521186 |
| 11 | Агрегат | 324 | 324 | 2746 | 1608677 |
| 12 | Агрегат | 269 | 269 | 2718 | 1606588 |
| 13 | Агрегат | 155 | 155 | 2880 | 1612142 |
| 14 | Агрегат | 212 | 212 | 2750 | 1468367 |
| 15 | Агрегат | 23 | 23 | 21721 | 1519916 |
| 16 | Агрегат | 15 | 15 | 1058970 | 1150787 |
| 17 | Агрегат | 308 | 308 | 2729 | 1612124 |
| 18 | Агрегат | 167 | 167 | 15581 | 1612588 |
| 19 | Агрегат | 183 | 183 | 3528 | 1612583 |
| 20 | Агрегат | 175 | 175 | 24492 | 1612600 |
| 21 | Агрегат | 222 | 222 | 7168 | 1612936 |
| 22 | Агрегат | 412 | 412 | 6071 | 1606156 |
| 23 | Агрегат | 139 | 139 | 3839 | 1606162 |
| 24 | Агрегат | 415 | 415 | 4554 | 1520674 |

**Важно:** Группа 0 больше не существует — разбита на индивидуальные группы 5-24 (поагрегатно).

**Особенность:** PSN НЕ плотные (пропусков ~1.6М), используются разрозненные значения.

**Итого:** 24 группы (1-2: планеры, 3-24: агрегаты), всего 7113 записей.

**Глобальный MAX(psn) = 1612936** (group_by=21)

**Архитектура сегментирования (100k на группу):**

| group_by | Тип | Диапазон PSN | Capacity |
|----------|-----|--------------|----------|
| 1 | Планеры Ми-8 | [2100000, 2200000) | 100000 |
| 2 | Планеры Ми-17 | [2200000, 2300000) | 100000 |
| **3** | **Двг Ми-8** | **[2300000, 2400000)** | **100000** |
| **4** | **Двг Ми-17** | **[2400000, 2500000)** | **100000** |
| 5 | Агрегат | [2500000, 2600000) | 100000 |
| 6 | Агрегат | [2600000, 2700000) | 100000 |
| 7 | Агрегат | [2700000, 2800000) | 100000 |
| 8 | Агрегат | [2800000, 2900000) | 100000 |
| 9 | Агрегат | [2900000, 3000000) | 100000 |
| 10 | Агрегат | [3000000, 3100000) | 100000 |
| 11 | Агрегат | [3100000, 3200000) | 100000 |
| 12 | Агрегат | [3200000, 3300000) | 100000 |
| 13 | Агрегат | [3300000, 3400000) | 100000 |
| 14 | Агрегат | [3400000, 3500000) | 100000 |
| 15 | Агрегат | [3500000, 3600000) | 100000 |
| 16 | Агрегат | [3600000, 3700000) | 100000 |
| 17 | Агрегат | [3700000, 3800000) | 100000 |
| 18 | Агрегат | [3800000, 3900000) | 100000 |
| 19 | Агрегат | [3900000, 4000000) | 100000 |
| 20 | Агрегат | [4000000, 4100000) | 100000 |
| 21 | Агрегат | [4100000, 4200000) | 100000 |
| 22 | Агрегат | [4200000, 4300000) | 100000 |
| 23 | Агрегат | [4300000, 4400000) | 100000 |
| 24 | Агрегат | [4400000, 4500000) | 100000 |

**Формула генерации:**
```
base_psn_group = 2000000 + (group_by × 100000)
psn = base_psn_group + spawn_counter_group
```
где `spawn_counter_group` — счетчик созданных агентов **внутри группы** (0, 1, 2, ..., 99999)

**Примеры:**
- Первый новый двигатель Ми-8 (group_by=3): `psn = 2300000 + 0 = 2300000`
- Первый новый двигатель Ми-17 (group_by=4): `psn = 2400000 + 0 = 2400000`
- Первый новый агрегат группы 24: `psn = 4400000 + 0 = 4400000`

**Преимущества:**
- ✅ Чистое разделение 24 групп (легко определить тип по PSN)
- ✅ Запас 100k новых агентов на каждую группу
- ✅ Удобная диагностика: `group_by = (psn - 2000000) / 100000`
- ✅ Резерв для планеров (group_by=1,2) на будущее
- ✅ Поддержка полной структуры 24 групп (без group_by=0)

---

## 4. ЗАДАЧИ АРХИТЕКТУРЫ

### 4.1. Инициализация первичных статусов агрегатов (TODO)



**Требуется:**
1. Разработать алгоритм инициализации первичных статусов агрегатов (аналог логики планеров)
3. Учесть связь со статусом планера (operations, repair, assembly_trigger)
4. Валидация консистентности: агрегат не может быть в `operations` если его планер не в `operations`

**Дата создания:** 30.10.2025

---

## 5. АРХИТЕКТУРА SPAWN АГРЕГАТОВ

### 5.1. Технология (аналог планеров)

**Этап 1: Инициализация (setup_env)**

1. **Резервирование слотов в индексе:**
   - Существующие агрегаты из MP3 (например, group_by=3): idx=[0..N-1]
   - Зарезервированные слоты для spawn: idx=[N..N+RESERVE-1]
   - Пример: 520 двигателей Ми-8 + 100 резервных слотов = 620 total
   - ⚠️ **ВАЖНО:** Резервные слоты создаются **пустыми** (только `idx` и `psn`)

2. **Предрасчёт PSN для резерва:**
   - Формула: base_psn_group = 2000000 + (group_by × 100000)
   - Для group_by=3: base_psn начинается с 2300000
   - Каждый новый агрегат получает следующий PSN: 2300000, 2300001, 2300002...
   - При инициализации резервных слотов:
     ```python
     for i in range(reserve_slots):
         reserve_idx = existing_count + i
         reserve_psn = base_psn_group + i
         # Остальные переменные НЕ заполняются (остаются пустыми/нулевыми)
         # Заполнение произойдёт при реальном spawn через RTC
     ```

3. **Размеры MacroProperty:**
   - **MAX_FRAMES** = общее количество агентов (планеры + агрегаты + резерв для spawn)
     - Для планеров: 279 (163 Mi-8 + 116 Mi-17)
     - Для агрегатов: будет определяться аналогично (существующие + резерв)
   - **MAX_DAYS** = 4000 (максимальный горизонт симуляции)
   - **MAX_SIZE** = MAX_FRAMES × (MAX_DAYS + 1) — размер линейного массива MP5

**Этап 2: RTC Spawn**

1. **Агенты-утилиты:**
   - `spawn_mgr_unit_{group_by}` — менеджер (1 экземпляр), хранит `next_idx`, `next_psn`
   - `spawn_ticket_unit_{group_by}` — тикеты (N экземпляров), параллельное создание

2. **RTC функция spawn:**
   - Читает триггер (дефицит агрегатов в пуле или замена на планере)
   - Берёт `idx` и `psn` из менеджера (предрасчитанные значения)
   - Создаёт агента через `agent_out` со всеми переменными из таблицы инициализации (раздел 2)
   - Устанавливает `partseqno_i` по логике выбора типа (см. Этап 5)
   - Устанавливает нормативы (ll, oh, br) из Environment constants для данной group_by

3. **Выход в состояние:**
   - Spawn в пул → state `reserve` (готов к установке)
   - Spawn на замену → state `operations` (сразу на планере)
   - State `inactive` для агрегатов НЕ используется

**Этап 3: Триггер spawn**

- **Для планеров:** Детерминированный план (`mp4_new_counter_mi17_seed[day] > 0`)
- **Для агрегатов:** **Динамический подсчёт дефицита** в пуле

**Формула триггера spawn для агрегатов (для каждой group_by):**

```python
# Подсчёт агентов в пуле (готовых к установке)
pool_count = count_agents(group_by, states=[reserve, serviceable])

# Норма пула = количество планеров × comp_number (из MP1)
# comp_number = количество одноимённых агрегатов на 1 вертолёт
pool_norm = count_planers(group_by_planer) × comp_number

# Триггер spawn
if pool_count < pool_norm:
    spawn_need = pool_norm - pool_count
    spawn_agents(group_by, spawn_need)
```

**Пример для двигателей Ми-8 (group_by=3):**
- `comp_number` = 2 (два двигателя на один Ми-8)
- Планеров Ми-8 в operations: 120
- `pool_norm` = 120 × 2 = 240 двигателей
- `pool_count` (reserve + serviceable): 220 двигателей
- `spawn_need` = 240 - 220 = **20 двигателей**

**Важно:** Триггер проверяется **каждый день** перед началом симуляции.

**Этап 4: Расчёт резервных кадров**

Формула резервирования через **прогноз выработки ресурса** (из архивного кода vNV):

```python
# Для каждой group_by агрегатов (3, 4, 5, ..., 24):

# 1. Определяем связь с планерами через ac_type_mask
# ac_type_mask агрегата определяет, на каких планерах он используется:
# - 32 (0x20) → Ми-8 (group_by=1)
# - 64 (0x40) → Ми-17 (group_by=2)
# - 96 (0x60) → оба типа (универсальный)
planer_group_by = determine_planer_group(aggregate_group_by, ac_type_mask)

# 2. Суммарный налёт планеров за 10 лет (из MP2 прогноза)
total_flight_hours_10y = sum([
    mp2_dt[day, idx] 
    for day in range(0, 3650)
    for idx in planers 
    if planers[idx].group_by == planer_group_by
])

# 3. LL агрегата из MP1 (жизненный лимит в минутах)
ll_aggregate = mp1_ll[aggregate_group_by]

# 4. Количество агрегатов, которые выработают ресурс
aggregates_consumed = total_flight_hours_10y / ll_aggregate

# 5. Добавляем запас прочности 20%
aggregates_needed = aggregates_consumed × 1.2

# 6. Подсчёт существующих агрегатов из MP3
existing_count = len([row for row in MP3 if row.group_by == aggregate_group_by])

# 7. Расчёт резервных слотов
reserve_slots = max(100, aggregates_needed - existing_count)

# 8. Итоговое количество frames для группы
frames_total_group = existing_count + reserve_slots

# 9. Общий MAX_FRAMES для всех агентов
MAX_FRAMES = sum([frames_total_group for group_by in [1, 2, 3, 4, ..., 24]])
```

**Пример для двигателей Ми-17 (group_by=4):**
- Планеров Ми-17: 116
- Суммарный налёт за 10 лет: 116 × 3650 дней × 90 мин/день = **38,232,000 минут**
- LL двигателя: 270,000 минут (4500 часов)
- Агрегатов выработают ресурс: 38,232,000 / 270,000 = **141.6**
- С запасом 20%: 141.6 × 1.2 = **170 двигателей**
- Существующих: 384
- Резерв: max(100, 170 - 384) = **100** (минимальный резерв)
- Итого: 384 + 100 = **484 слота**

**Этап 5: Логика выбора partseqno_i для нового агрегата**

При замене агрегата:
1. **Читаем `partseqno_i` снятого агрегата**
2. **Проверяем MP1 по этому `partseqno_i`:**
   - Если `sne_new` и `ppr_new` **НЕ пустые** →
     - `partseqno_i` = `partseqno_i` снятого агрегата (тот же тип)
     - `sne` = `sne_new` из MP1
     - `ppr` = `ppr_new` из MP1
   - Если `sne_new` и `ppr_new` **пустые** →
     - `partseqno_i` = `partseqno_i` **последнего созданного агрегата** с той же `group_by` (по максимальному `idx`)
     - `sne` = 0
     - `ppr` = 0

**Алгоритм:**
- Проверяем наличие `sne_new` и `ppr_new` в MP1 для `partseqno_i` снятого агрегата
- Если значения присутствуют → создаём новый агрегат того же типа с начальной наработкой из MP1
- Если значения отсутствуют (тип не выпускается) → ищем фильтром агента с той же `group_by` и максимальным `idx`, используем его `partseqno_i` для нового агрегата с нулевой наработкой

**Технически:** Не храним дополнительные счётчики типов — динамический поиск по агентам быстрый (агентов в группе немного).

**Примечание:** Это происходит при замене, т.е. новый агрегат может создаваться сразу в `operations` (установлен на планер), а не обязательно в `reserve`.

**Дата:** 31.10.2025

---

## 6. РЕАЛИЗАЦИЯ ИНТЕГРАЦИИ SNE_NEW/PPR_NEW (31.10.2025)

### 6.1. Проблема
Для spawn агрегатов требуется начальная наработка (`sne`, `ppr`) из справочника `md_components` (поля `sne_new`, `ppr_new`). Эти значения хранятся в **часах** в Excel-источнике, но симуляция работает в **минутах**.

### 6.2. Решение

**Этап 1: ETL (Extract)**
- **Файл:** `code/md_components_loader.py`
- **Изменения:**
  1. Добавлена конвертация `sne_new` и `ppr_new` из часов в минуты (× 60)
  2. Сохранение `NULL` значений (признак "агрегат не выпускается")
  3. Корректная обработка `Nullable(UInt32)` при вставке в ClickHouse

**Этап 2: Симуляция (Transform)**
- **Файл:** `code/sim_env_setup.py`
- **Изменения:**
  1. Новая функция `fetch_mp1_sne_ppr_new()` — загрузка `sne_new`/`ppr_new` из `md_components`
  2. Конвертация `NULL` → `SENTINEL` (0xFFFFFFFF) для FLAME GPU Environment
  3. Добавление массивов `mp1_sne_new` и `mp1_ppr_new` в Environment

- **Файл:** `code/sim_v2/base_model.py`
- **Изменения:**
  1. Объявление Environment Property Arrays: `mp1_sne_new`, `mp1_ppr_new`
  2. Создание Environment constants: `mi17_sne_new_const`, `mi17_ppr_new_const`
  3. Конвертация `SENTINEL` → `0` для RTC использования

- **Файл:** `code/sim_v2/rtc_modules/rtc_spawn_v2.py`
- **Изменения:**
  1. Замена хардкода `0u` на чтение из Environment constants
  2. Логирование начальной наработки при spawn

### 6.3. Архитектурные решения

**Обработка NULL значений:**
- **В СУБД:** `Nullable(UInt32)` — NULL означает "агрегат не выпускается"
- **В FLAME GPU:** Sentinel value `0xFFFFFFFF` (Environment не поддерживает Nullable)
- **В RTC коде:** Sentinel → `0` (новый агрегат без наработки)

**Конвертация единиц:**
- **Excel источник:** часы (4500-7500)
- **СУБД:** минуты (270000-450000)
- **Симуляция:** минуты (все расчеты в минутах)

### 6.4. Валидация

**Проверка СУБД:**
```sql
SELECT partno, sne_new, ppr_new
FROM md_components
WHERE sne_new IS NOT NULL AND sne_new > 0
```

**Результат:**
- ТВ2-117А: 270000 минут (4500 часов) ✅
- ТВ3-117ВМ: 270000 минут (4500 часов) ✅
- АИ-9В: 360000 минут (6000 часов) ✅
- ВР-8А: 450000 минут (7500 часов) ✅

**Проверка симуляции:**
- Полный прогон 3650 дней: ✅ Успешно
- Spawn планеров (Mi-17): `sne=0, ppr=0` ✅ (для планеров правильно)
- Выгрузка MP2: 1039632 строк за 21.71с ✅

### 6.5. Итоги

✅ **Интеграция завершена:**
1. ETL корректно конвертирует часы→минуты с сохранением NULL
2. Симуляция загружает значения через MP1 arrays
3. RTC spawn готов использовать `sne_new`/`ppr_new` для агрегатов
4. Для планеров (Mi-17) spawn использует `0` (правильное поведение)

**Дата реализации:** 31.10.2025

---

**Статус:** ✅ Архитектура согласована. Интеграция sne_new/ppr_new реализована и протестирована (31.10.2025).

---

## 7. ОСОБЫЕ СЛУЧАИ РЕМОНТА/ПРОДЛЕНИЯ

### 7.1. Лопасти (group_by=6): продление без обнуления ppr

**Дата добавления:** 02.01.2026

**Проблема:**
Лопасти (group_by=6, номенклатуры `8АТ-2710-00`, `8АТ.2710.000`) не проходят капитальный ремонт в классическом понимании. Вместо этого применяется **продление назначенного ресурса** — агрегат продолжает эксплуатацию без обнуления наработки.

**Решение:**

1. **Валидация (validate_heli_pandas.py):**
   - Для group_by=6 **НЕ проверяется** условие `ppr > oh`
   - Проверка `sne > ll` остаётся активной
   - Обоснование: ppr накапливается без обнуления, превышение oh — штатная ситуация

2. **Симуляция (RTC spawn/repair):**
   - При "ремонте" (продлении) лопастей **НЕ обнуляем ppr**
   - Агрегат возвращается в эксплуатацию с тем же значением ppr
   - Контроль по `sne > ll` остаётся критичным

**Технически в RTC:**
```cuda
// При возврате агрегата из ремонта:
if (group_by == 6) {
    // Лопасти: ppr НЕ обнуляется (продление, не ремонт)
    // ppr сохраняет накопленное значение
} else {
    // Остальные агрегаты: классический ремонт
    ppr = 0;  // Обнуление после капремонта
}
```

**Ресурсы лопастей в md_components:**
| partno | ll_mi8 | ll_mi17 | oh_mi8 | oh_mi17 |
|--------|--------|---------|--------|---------|
| 8АТ-2710-00 | 150,000 | 150,000 | 120,000 | 120,000 |
| 8АТ.2710.000 | 150,000 | 150,000 | 120,000 | 120,000 |

**Примечание:** oh для лопастей фактически означает "интервал до очередного продления", а не "межремонтный ресурс" в классическом понимании.

