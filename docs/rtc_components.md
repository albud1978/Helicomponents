# RTC Components Architecture (Агрегаты)

**Дата:** 30.10.2025  
**Версия:** 0.1

---

## 1. ПЕРЕМЕННЫЕ АГЕНТОВ

### Агрегаты (Agent "unit")

| Категория | Переменные | Δ от планеров |
|-----------|------------|---------------|
| **States** | operations, serviceable, repair, reserve, storage | -inactive |
| **ID** | idx, **psn**, aircraft_number, partseqno_i, group_by | +psn (PRIMARY KEY) |
| **Наработка** | sne, ppr | -cso |
| **Нормативы** | ll, oh, br | = |
| **Ремонт** | repair_time, repair_days | -assembly_time, -partout_time |
| **Триггеры** | — | -assembly_trigger, -active_trigger, -partout_trigger, -s4_days |
| **MP2 планера** | dt, dn | читаются из mp2_dt/mp2_dn по aircraft_number |
| **Квоты** | intent_state, mfg_date | = |
| **Transitions** | transition_2_to_3, transition_2_to_4, transition_2_to_6, transition_3_to_2, transition_4_to_5, transition_5_to_2 | -transition_1_to_2, -transition_1_to_4, -transition_4_to_2 |
| **Служебное** | bi_counter | = |

**Итого:** 23 переменных (vs 33 у планеров)

**Важно:** 
- State `inactive` у агрегатов НЕ используется (новые агрегаты создаются в `reserve`)
- Transition `1→2` НЕ нужен (нет inactive state)
- Spawn агрегатов идёт сразу в `reserve` (готов к установке на планер)

---

## 2. ИСТОЧНИКИ ИНИЦИАЛИЗАЦИИ

### Таблица источников данных при создании агентов

| Переменная | Источник (MP3) | Логика инициализации (существующие) | Логика spawn (новые inactive) |
|------------|----------------|-------------------------------------|-------------------------------|
| **idx** | Плотный индекс | Начинается с (last_idx_планеров + 1), сортировка по mfg_date внутри group_by | Зарезервированный idx в конце группы |
| **psn** | MP3.psn | PRIMARY KEY агрегата, уникальный идентификатор | Сегмент: 2000000 + (group_by × 100000) + counter |
| **aircraft_number** | MP3.aircraft_number | Номер планера-родителя (0 если в пуле) | 0 (в пуле до установки) |
| **partseqno_i** | MP3.partseqno_i | Код типа агрегата из справочника | Константа для group_by (из Env) |
| **group_by** | MP3.group_by | Тип агрегата (3=Двг Ми-8, 4=Двг Ми-17) | Константа: 3 или 4 |
| **sne** | MP3.sne | Наработка с начала эксплуатации (минуты) | MP3.sne_new (если пусто → 0) |
| **ppr** | MP3.ppr | Наработка после последнего капремонта | MP3.ppr_new (если пусто → 0) |
| **ll** | MP3.ll или MP1 | Если MP3.ll > 0 → MP3, иначе MP1 по group_by | MP1 по group_by |
| **oh** | MP1 | По partseqno_i через mp1_index | MP1 по group_by |
| **br** | MP1 | По partseqno_i через mp1_index | MP1 по group_by |
| **repair_time** | MP1 | mp1_repair_time[pidx] | MP1 по group_by |
| **repair_days** | MP3.repair_days | Счетчик дней в ремонте | 0 (новый агрегат) |
| **intent_state** | Константа | 0 (без намерений) | 0 (без намерений) |
| **mfg_date** | MP3.mfg_date | Дата производства (дни с эпохи) | 0 (установится при установке на планер) |
| **dt, dn** | MP2 | Чтение по aircraft_number из mp2_dt/mp2_dn планера | 0 (aircraft_number=0) |
| **bi_counter** | Константа | 1 (для BI) | 1 (для BI) |
| **transition_*** | Константы | 0 (без переходов) | 0 (без переходов) |
| **state** | MP3.status_id | Маппинг status_id → state | reserve (готов к установке) |

**Особенности:**
- Фильтрация: из ~7113 строк MP3 берутся только записи с `group_by ∈ {3,4}` (сначала 3, потом 4; остальные группы добавятся позже)
- **Уникальность: один агент = один `psn` (PRIMARY KEY), не aircraft_number**
  - ⚠️ **ВАЖНО:** У планеров (group_by=1,2) переменной `psn` НЕТ! Используется только `aircraft_number`
  - У агрегатов (group_by≥3) `psn` — обязательное поле (PRIMARY KEY в СУБД)
- Связь с планером: через `aircraft_number` (0 = в пуле, >0 = на конкретном планере)
- Индексация: плотный индекс начинается после последнего idx планеров, последовательно: сначала все group_by=3, затем все group_by=4
- Сортировка: по mfg_date (от старых к новым) внутри каждой group_by
- Spawn-резерв: слоты в конце каждой группы, новые агрегаты создаются в state=reserve (без mfg_date)

---

---

## 3. АНАЛИЗ ДИАПАЗОНОВ PSN

### Текущие диапазоны в heli_pandas (обновлено 30.10.2025)

| group_by | Тип | Всего | Уник.PSN | MIN(psn) | MAX(psn) |
|----------|-----|-------|----------|----------|----------|
| 1 | Планеры Ми-8 | 163 | 163 | 148724 | 922207 |
| 2 | Планеры Ми-17 | 116 | 116 | 148717 | 1459322 |
| **3** | **Двг Ми-8** | **520** | **520** | **2702** | **1606586** |
| **4** | **Двг Ми-17** | **384** | **384** | **2760** | **1519814** |
| 5 | Агрегат | 264 | 264 | 2715 | 1543914 |
| 6 | Агрегат | 1588 | 1588 | 6557 | 1612576 |
| 7 | Агрегат | 248 | 248 | 2934 | 1521154 |
| 8 | Агрегат | 287 | 287 | 2778 | 1521178 |
| 9 | Агрегат | 275 | 275 | 2716 | 1521182 |
| 10 | Агрегат | 249 | 249 | 2777 | 1521186 |
| 11 | Агрегат | 324 | 324 | 2746 | 1608677 |
| 12 | Агрегат | 269 | 269 | 2718 | 1606588 |
| 13 | Агрегат | 155 | 155 | 2880 | 1612142 |
| 14 | Агрегат | 212 | 212 | 2750 | 1468367 |
| 15 | Агрегат | 23 | 23 | 21721 | 1519916 |
| 16 | Агрегат | 15 | 15 | 1058970 | 1150787 |
| 17 | Агрегат | 308 | 308 | 2729 | 1612124 |
| 18 | Агрегат | 167 | 167 | 15581 | 1612588 |
| 19 | Агрегат | 183 | 183 | 3528 | 1612583 |
| 20 | Агрегат | 175 | 175 | 24492 | 1612600 |
| 21 | Агрегат | 222 | 222 | 7168 | 1612936 |
| 22 | Агрегат | 412 | 412 | 6071 | 1606156 |
| 23 | Агрегат | 139 | 139 | 3839 | 1606162 |
| 24 | Агрегат | 415 | 415 | 4554 | 1520674 |

**Важно:** Группа 0 больше не существует — разбита на индивидуальные группы 5-24 (поагрегатно).

**Особенность:** PSN НЕ плотные (пропусков ~1.6М), используются разрозненные значения.

**Итого:** 24 группы (1-2: планеры, 3-24: агрегаты), всего 7113 записей.

**Глобальный MAX(psn) = 1612936** (group_by=21)

**Архитектура сегментирования (100k на группу):**

| group_by | Тип | Диапазон PSN | Capacity |
|----------|-----|--------------|----------|
| 1 | Планеры Ми-8 | [2100000, 2200000) | 100000 |
| 2 | Планеры Ми-17 | [2200000, 2300000) | 100000 |
| **3** | **Двг Ми-8** | **[2300000, 2400000)** | **100000** |
| **4** | **Двг Ми-17** | **[2400000, 2500000)** | **100000** |
| 5 | Агрегат | [2500000, 2600000) | 100000 |
| 6 | Агрегат | [2600000, 2700000) | 100000 |
| 7 | Агрегат | [2700000, 2800000) | 100000 |
| 8 | Агрегат | [2800000, 2900000) | 100000 |
| 9 | Агрегат | [2900000, 3000000) | 100000 |
| 10 | Агрегат | [3000000, 3100000) | 100000 |
| 11 | Агрегат | [3100000, 3200000) | 100000 |
| 12 | Агрегат | [3200000, 3300000) | 100000 |
| 13 | Агрегат | [3300000, 3400000) | 100000 |
| 14 | Агрегат | [3400000, 3500000) | 100000 |
| 15 | Агрегат | [3500000, 3600000) | 100000 |
| 16 | Агрегат | [3600000, 3700000) | 100000 |
| 17 | Агрегат | [3700000, 3800000) | 100000 |
| 18 | Агрегат | [3800000, 3900000) | 100000 |
| 19 | Агрегат | [3900000, 4000000) | 100000 |
| 20 | Агрегат | [4000000, 4100000) | 100000 |
| 21 | Агрегат | [4100000, 4200000) | 100000 |
| 22 | Агрегат | [4200000, 4300000) | 100000 |
| 23 | Агрегат | [4300000, 4400000) | 100000 |
| 24 | Агрегат | [4400000, 4500000) | 100000 |

**Формула генерации:**
```
base_psn_group = 2000000 + (group_by × 100000)
psn = base_psn_group + spawn_counter_group
```
где `spawn_counter_group` — счетчик созданных агентов **внутри группы** (0, 1, 2, ..., 99999)

**Примеры:**
- Первый новый двигатель Ми-8 (group_by=3): `psn = 2300000 + 0 = 2300000`
- Первый новый двигатель Ми-17 (group_by=4): `psn = 2400000 + 0 = 2400000`
- Первый новый агрегат группы 24: `psn = 4400000 + 0 = 4400000`

**Преимущества:**
- ✅ Чистое разделение 24 групп (легко определить тип по PSN)
- ✅ Запас 100k новых агентов на каждую группу
- ✅ Удобная диагностика: `group_by = (psn - 2000000) / 100000`
- ✅ Резерв для планеров (group_by=1,2) на будущее
- ✅ Поддержка полной структуры 24 групп (без group_by=0)

---

## 4. ЗАДАЧИ АРХИТЕКТУРЫ

### 4.1. Инициализация первичных статусов агрегатов (TODO)



**Требуется:**
1. Разработать алгоритм инициализации первичных статусов агрегатов (аналог логики планеров)
3. Учесть связь со статусом планера (operations, repair, assembly_trigger)
4. Валидация консистентности: агрегат не может быть в `operations` если его планер не в `operations`

**Дата создания:** 30.10.2025

---

## 5. АРХИТЕКТУРА SPAWN АГРЕГАТОВ

### 5.1. Технология (аналог планеров)

**Этап 1: Инициализация (setup_env)**

1. **Резервирование слотов в индексе:**
   - Существующие агрегаты из MP3 (например, group_by=3): idx=[0..N-1]
   - Зарезервированные слоты для spawn: idx=[N..N+RESERVE-1]
   - Пример: 520 двигателей Ми-8 + 100 резервных слотов = 620 total

2. **Предрасчёт PSN для резерва:**
   - Формула: base_psn_group = 2000000 + (group_by × 100000)
   - Для group_by=3: base_psn начинается с 2300000
   - Каждый новый агрегат получает следующий PSN: 2300000, 2300001, 2300002...

3. **Размеры MacroProperty:**
   - MAX_FRAMES = максимум среди всех групп (1..24)
   - MAX_SIZE = MAX_FRAMES × (MAX_DAYS + 1)

**Этап 2: RTC Spawn**

1. **Агенты-утилиты:**
   - `spawn_mgr_unit_{group_by}` — менеджер (1 экземпляр), хранит `next_idx`, `next_psn`
   - `spawn_ticket_unit_{group_by}` — тикеты (N экземпляров), параллельное создание

2. **RTC функция spawn:**
   - Читает триггер (дефицит агрегатов в пуле или замена на планере)
   - Берёт `idx` и `psn` из менеджера (предрасчитанные значения)
   - Создаёт агента через `agent_out` со всеми переменными из таблицы инициализации (раздел 2)
   - Устанавливает `partseqno_i` по логике выбора типа (см. Этап 5)
   - Устанавливает нормативы (ll, oh, br) из Environment constants для данной group_by

3. **Выход в состояние:**
   - Spawn в пул → state `reserve` (готов к установке)
   - Spawn на замену → state `operations` (сразу на планере)
   - State `inactive` для агрегатов НЕ используется

**Этап 3: Триггер spawn**

- **Для планеров:** Детерминированный план (`mp4_new_counter_mi17_seed[day] > 0`)
- **Для агрегатов:** **Динамический подсчёт дефицита** в пуле (reserve + serviceable < норма)

**Этап 4: Расчёт резервных кадров**

Формула резервирования (аналог планеров):
- Для каждой group_by определяем максимальную потребность за 10 лет
- `max_needed` = максимальное количество агрегатов в operations за период + запас прочности
- `reserve_slots` = max(100, max_needed - existing_count)
- `frames_total` = existing_count + reserve_slots

**Этап 5: Логика выбора partseqno_i для нового агрегата**

При замене агрегата:
1. **Читаем `partseqno_i` снятого агрегата**
2. **Проверяем MP1 по этому `partseqno_i`:**
   - Если `sne_new` и `ppr_new` **НЕ пустые** →
     - `partseqno_i` = `partseqno_i` снятого агрегата (тот же тип)
     - `sne` = `sne_new` из MP1
     - `ppr` = `ppr_new` из MP1
   - Если `sne_new` и `ppr_new` **пустые** →
     - `partseqno_i` = `partseqno_i` **последнего созданного агрегата** с той же `group_by` (по максимальному `idx`)
     - `sne` = 0
     - `ppr` = 0

**Алгоритм:**
- Проверяем наличие `sne_new` и `ppr_new` в MP1 для `partseqno_i` снятого агрегата
- Если значения присутствуют → создаём новый агрегат того же типа с начальной наработкой из MP1
- Если значения отсутствуют (тип не выпускается) → ищем фильтром агента с той же `group_by` и максимальным `idx`, используем его `partseqno_i` для нового агрегата с нулевой наработкой

**Технически:** Не храним дополнительные счётчики типов — динамический поиск по агентам быстрый (агентов в группе немного).

**Примечание:** Это происходит при замене, т.е. новый агрегат может создаваться сразу в `operations` (установлен на планер), а не обязательно в `reserve`.

**Дата:** 30.10.2025

---

**Статус:** ✅ Согласовано. Данные перезагружены (30.10.2025).

