# RTC Components Architecture (Агрегаты) — Этап 1: Двигатели & FIFO

**Дата:** 22.12.2025
**Статус:** Утверждено к разработке
**Фокус:** Двигатели (Group 3 & 4), FIFO склад, Односторонняя связь

## 1. Архитектурные Принципы (Multi-BOM)

1.  **Иерархия (Parent-Child):**
    *   **Уровень 1 (Планеры):** Ведущие. Определяют налет (`dt`), списание, потребность в установке.
    *   **Уровень 2 (Агрегаты):** Ведомые. Читают состояние планеров из MP2.
    *   **Связь:** Односторонняя (Планеры → MP2 → Агрегаты). Агрегаты не блокируют планеры.

2.  **Политика Оборота:**
    *   **Склад (Reserve):** FIFO (First In, First Out). При потребности берется двигатель с минимальным `fifo_idx`.
    *   **Дефицит:** Если на складе нет исправных → Spawn (рождение нового).
    *   **Замена:**
        *   По ресурсу агрегата (`ppr >= oh`).
        *   По событию планера (списание/тяжелый ремонт).

3.  **Данные и Индексы:**
    *   **Индексация:** Плотная, последовательная. Сначала все Планеры, затем Двигатели Гр.3, затем Двигатели Гр.4.
    *   **FIFO Index:** Монотонно растущий индекс `fifo_idx` для однозначного определения очередности.

---

## 2. Переменные Агента (Engine Agent)

В дополнение к стандартным (`sne`, `ppr`, `status_id`), агрегат имеет специфичные поля для связки:

| Переменная | Тип | Назначение |
| :--- | :--- | :--- |
| `idx` | `uint` | Глобальный индекс в симуляции (уникальный) |
| `aircraft_number` | `uint` | Номер борта установки (0 = на складе) |
| `parent_idx` | `uint` | **Кэш индекса планера** в массиве MP2 (для быстрого чтения). `MAX_UINT` если на складе. |
| `fifo_idx` | `uint` | Индекс для сортировки очереди склада (monotonically increasing) |
| `group_by` | `uint` | 3 (Ми-8) или 4 (Ми-17) |
| `psn` | `uint` | Серийный номер (Primary Key) |

---

## 3. Логика RTC Модулей (Pipeline)

### 3.1. Initialization (Python/ETL)
*   **Статусы:** Проставляются в ETL (`heli_pandas_component_status.py`) на основе родительского планера.
*   **Индексы:** Двигатели загружаются после планеров.
*   **FIFO:** `fifo_idx` инициализируется при загрузке (сортировка по `mfg_date`).

### 3.2. Operations Logic (RTC)
*   **Вход:** Агрегат в статусе `Operations` (`parent_idx != MAX_UINT`).
*   **Действие:**
    1.  Чтение MP2 планера по `parent_idx`.
    2.  `dt_engine = mp2_planes[parent_idx].dt`.
    3.  `sne += dt`, `ppr += dt`.
    4.  **Проверка ресурса:** Если `ppr >= oh` → `Intent = 4` (Repair).
    5.  **Проверка родителя:** Если планер ушел в `Storage` → `Intent = 5` (Reserve).

### 3.3. Assembly Manager (Балансировщик)
*   **Задача:** Распределить свободные двигатели на пустые места.
*   **Спрос (Demand):**
    *   Планеры с `assembly_trigger == 1` (выход из ремонта).
    *   Планеры, где двигатель ушел в ремонт (образовалась дырка).
*   **Предложение (Supply):**
    *   Агрегаты в `Reserve`.
*   **Алгоритм (FIFO):**
    1.  Собрать список потребностей (Demand List).
    2.  Собрать список свободных (Supply List), отсортированных по `fifo_idx`.
    3.  Назначить: `Supply[i]` → `Demand[i]`.
    4.  Обновить у агрегата: `aircraft_number`, `parent_idx`, `Intent = 2`.

### 3.4. Spawn Manager
*   **Условие:** Если `Demand > Supply` (не хватило двигателей на складе).
*   **Действие:**
    1.  Активировать резервные слоты (Empty → Reserve).
    2.  Присвоить новый `fifo_idx` (max + 1).
    3.  Сразу отправить в `Operations` (закрыть дефицит) или в `Reserve` (на следующем шаге заберет Assembly Manager).

---

## 4. Контракт MP2 (Interface)

Агрегаты читают из MP2 планеров следующие поля:
1.  `dt` (налет сегодня) — для начисления ресурса.
2.  `state` (состояние) — для реакции на списание/ремонт.
3.  `assembly_trigger` — сигнал потребности в комплектации.

---

## 5. План реализации (TODO Summary)

1.  **ETL:** Доработка статусов (`aircraft_number > 0` → `Operations`).
2.  **Loader:** Загрузка Гр.3/4, генерация `fifo_idx`.
3.  **RTC Ops:** Чтение налета с планера.
4.  **RTC Assembly:** FIFO распределение.
5.  **RTC Spawn:** Покрытие дефицита.
