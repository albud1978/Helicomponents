# Helicomponents — глубокий анализ и рекомендации

## 1. Что я вижу в проекте сейчас

Алексей, проект Helicomponents — это серьёзная, зрелая система прогнозирования жизненного цикла компонентов вертолётов. По README, 514 коммитов, структурированная документация, продуманная архитектура. Выделю ключевые характеристики текущего состояния:

**Технологическое ядро** — FLAME GPU 2.0.0rc4 на CUDA 13.0 с Python-обёрткой (pyflamegpu). Агент-Based моделирование на GPU — это правильный выбор для симуляции тысяч компонентов с параллельными жизненными циклами. RTC-компиляция с кэшированием (`.rtc_cache`) ускоряет повторные запуски, что критично для итеративной разработки модели.

**ETL-пайплайн** — полный цикл extract → transform → load с ClickHouse в качестве хранилища. Присутствуют cuDF для GPU-ускоренной обработки данных, pandas для аналитики, интерактивный выбор датасетов и режимов. Два формата MP2-экспорта (short/full) говорят о том, что система обслуживает разные сценарии потребления данных.

**Модель агентов** — чётко определённые статусы (Inactive → Operations → Serviceable → Repair → Reserve → Storage), битовые маски типов ВС (МИ-8Т/МИ-8АМТ/МИ-26), система error_flags с 6-ю типами валидационных ошибок. Динамический спавн с разделёнными диапазонами нумерации (реальные борта до 99999, spawn 100000–999999). Бизнес-логика beyond repair (br), межремонтный ресурс (oh), назначенный ресурс (ll) — всё это отражает реальную авиационную предметную область.

**Документированность** — явная политика «недокументированный хардкод запрещён», аудит хардкодов, таблицы констант с привязкой к файлам. Это зрелый подход, редко встречаемый даже в коммерческих проектах.

**Ветка `feature/flame-messaging`** и коммит `ac2bc20c` — к сожалению, я не смог получить прямой доступ к содержимому этой feature-ветки через GitHub (она видимо не в master). Но по названию это работа над **межагентной коммуникацией в FLAME GPU** — messaging между агентами симуляции. Это критический следующий шаг, и именно здесь пересекается твоё исследование по мультиагентности с архитектурой проекта.

---

## 2. Анализ: где Helicomponents сейчас на «карте зрелости»

Сопоставлю текущее состояние проекта с твоим исследованием трендов мультиагентности 2025–2026.

### Что уже хорошо реализовано

**Чёткое разделение ответственности** — проект уже имеет модульную структуру: `code/sim_v2/` (оркестратор симуляции), отдельные модули для ETL, валидации, enrichment, анализа. Это соответствует тренду «микросервисный момент для агентов».

**Единый источник правды** — ClickHouse как хранилище + документированные константы из `MD_Components.xlsx` + `.cursorrules` как центральный конфигурационный файл. Это то, что в исследовании называется «shared memory / single source of truth / blackboard».

**Валидация и governance** — система error_flags с битовыми масками, процедура `sim_validation_transitions.py`, правила комплектности — это зачатки того, что в мультиагентной архитектуре называется Critic/Governance layer.

**Документированный audit trail** — changelog, tasktracker, история аудита хардкодов. В терминах исследования — «логирование reasoning-шагов и аудит действий агентов».

### Где есть разрыв (gap)

**Один «суперагент» vs команда** — сейчас Cursor-агент работает как единый Orchestrator+Implementer. Исследование однозначно говорит: в production-сценариях это антипаттерн. При 514 коммитах и растущей сложности один агент начинает терять контекст.

**Нет явного Researcher-агента** — доменные знания (PBM-модели, регламенты, параметры деградации) сейчас «зашиты» в код и `.cursorrules`. Нет механизма, который бы структурированно извлекал, обновлял и проверял доменную информацию.

**Critic работает вручную** — валидация переходов и проверка комплектности запускаются как отдельные скрипты. Нет автоматического контура «реализация → оценка → корректировка».

**Hand-off между этапами неформализован** — переход от ETL к симуляции, от симуляции к отчётности происходит через «знание разработчика», а не через структурированные артефакты (Goal → Changes → Open Questions → Next Owner).

---

## 3. Рекомендации: мультиагентная архитектура для Helicomponents

### 3.1. Организационная схема агентов (файл `AGENTS.md` в корне)

Предлагаю 5 ролей, не больше — чтобы избежать «agent sprawl»:

| Роль | Реализация в Cursor | Зона ответственности |
|------|---------------------|---------------------|
| **Orchestrator** | Главный агент | Планирование, координация, агрегация результатов. Разбивает задачу на pipeline: data → model → sim → validate → report |
| **Domain Researcher** | Subagent | Работа с доменными знаниями: md_components, регламенты, параметры деградации, документация FLAME GPU. Обновляет Skills |
| **Code Implementer** | Subagent | Код: ETL, симуляция, утилиты. Запускает тесты, линтеры. Работает в feature-ветках |
| **Sim Validator (Critic)** | Subagent | Валидация: переходы, инварианты, комплектность, сравнение с эталонами. Формирует отчёты о расхождениях |
| **Data Pipeline** | Subagent | ETL/ELT: extract → transform → load в ClickHouse. Мониторинг качества данных |

Governance-функцию на текущем этапе оставляем за человеком (ты) + существующей системой error_flags. Выделять отдельного Governance-агента имеет смысл, когда система начнёт работать в production без постоянного надзора.

### 3.2. Skills для PBM-домена (3–5 базовых)

Конкретно под Helicomponents:

**SKILL 1: `PBM_lifecycle_model.md`** — модель жизненного цикла агрегатов. Содержит: статусы и переходы между ними (таблица status_id 1–6), правила деградации (sne, ppr, ll, oh, br), логику beyond repair, специфику лопастей (PPR=0 после ремонта). Это твой «brain dump» авиаинженера, но формализованный так, чтобы агент мог его использовать.

**SKILL 2: `ETL_pipeline.md`** — протокол работы с данными. Форматы входных Excel, маппинг полей, правила нормализации единиц (часы → минуты), валидация комплектности, взаимодействие с ClickHouse. Сейчас это разбросано по `docs/extract.md`, `docs/transform.md`, `docs/load.md`, `docs/data_validation.md` — Skills объединит в одну точку входа для агента.

**SKILL 3: `FLAME_GPU_simulation.md`** — протокол запуска и настройки симуляции. RTC-кэширование, MacroProperty буферы, параметры MAX_FRAMES/MAX_DAYS/MAX_SIZE, spawn-логика, messaging между агентами (это как раз то, что ты делаешь в `feature/flame-messaging`). Агент Code Implementer должен знать эти ограничения, не изобретая их заново каждый раз.

**SKILL 4: `validation_invariants.md`** — инварианты и правила проверки. Текущие 6 типов error_flags, валидация переходов, проверка комплектности, эталонные значения. Для Sim Validator субагента.

**SKILL 5: `reporting_formats.md`** — форматы выходных артефактов. MP2-экспорт (short/full), отчёты по ресурсу, defect-файлы (`blades_ppr_defects_*.xlsx`), markdown-отчёты валидации.

### 3.3. Workflow: как это работает в цикле

**Типичный цикл разработки фичи (например, flame-messaging):**

**Шаг 1 — Plan.** Orchestrator принимает цель: «Реализовать межагентное messaging в FLAME GPU для передачи статусов между планерами и агрегатами». Включает Planning Mode, формулирует подзадачи.

**Шаг 2 — Research.** Domain Researcher обращается к `PBM_lifecycle_model.md` и `FLAME_GPU_simulation.md`, изучает документацию FLAME GPU 2 по messaging (MessageBruteForce, MessageSpatial2D/3D, MessageArray), формирует контракт: какие данные передаются, между какими типами агентов, с какой частотой.

**Шаг 3 — Implement.** Code Implementer получает контракт, реализует messaging в `code/sim_v2/`, создаёт тесты. Работает в ветке `feature/flame-messaging`, использует git worktree если нужна параллельность.

**Шаг 4 — Validate.** Sim Validator запускает `sim_validation_transitions.py` на результатах, проверяет инварианты: не нарушены ли переходы статусов, корректно ли передаются ресурсы, нет ли «потерянных» агентов.

**Шаг 5 — Correct.** Orchestrator получает отчёт Validator'а. Если есть расхождения — возвращает задачу Implementer'у с конкретным списком проблем. Если всё OK — переходит к merge и обновлению документации.

**Hand-off артефакт между каждым шагом:**

```
Goal: Реализовать messaging планер→агрегат для передачи status_id
Changes: Добавлен MessageArray в model_build.py, новая agent function в rtc_units_state_*.py
Open Questions: Нужно ли messaging для spawn-агентов? Проверить совместимость с RTC-кэшем
Next Owner: Sim Validator → проверить инварианты на датасете v_2025-12-15
```

### 3.4. Конкретные рекомендации по `feature/flame-messaging`

Исходя из архитектуры проекта и FLAME GPU 2:

**Выбор стратегии messaging.** Для твоей модели, где планеры (group_by=1,2) управляют агрегатами, оптимален `MessageArray` или `MessageBucket` — агенты индексируются по `partseqno` или `framenumber`, что даёт O(1) доступ вместо O(N) при BruteForce. С учётом RTC_MAX_FRAMES=400 и MAX_DAYS=4000, BruteForce будет слишком медленным.

**Направления коммуникации:**
- Планер → агрегаты: broadcast решений о ремонте, списании, спавне
- Агрегат → планер: отчёт о текущем состоянии (sne, ppr, status_id, error_flags)
- Агрегат → агрегат: каннибализация (донор → реципиент), что связано со status_id=1 (Inactive)

**Совместимость с RTC.** Messaging-функции должны быть совместимы с RTC-кэшированием. Убедись, что новые agent functions экспортируются в `.rtc_cache` и при изменении контракта сообщения кэш инвалидируется.

**Интеграция с MacroProperty.** Текущие буферы MacroProperty (RTC_MAX_FRAMES × (MAX_DAYS + 1)) работают как «глобальная память». Messaging добавляет «точечную» коммуникацию. Нужно чётко разграничить: MacroProperty — для агрегированных данных уровня флота, messaging — для peer-to-peer взаимодействий.

### 3.5. Приоритеты внедрения

Рекомендую поэтапный подход, не пытаясь внедрить всё сразу:

**Фаза 1 (сейчас): Skills и `.cursor/rules`**. Создать 3–5 Skills из п. 3.2. Обновить `.cursorrules` с описанием ролей агентов. Это не требует изменений в коде и сразу улучшит качество работы с Cursor.

**Фаза 2 (после merge `feature/flame-messaging`): Subagents**. Настроить Sim Validator как отдельный субагент, который автоматически запускает валидацию после каждого изменения в `code/sim_v2/`. Это самый высокий ROI — ловить ошибки на раннем этапе.

**Фаза 3 (стабилизация): Domain Researcher**. Когда появляются новые типы ВС или меняются регламенты — Researcher структурирует изменения, обновляет Skills, а Implementer получает уже готовый контракт.

**Фаза 4 (масштабирование): полный pipeline**. Orchestrator координирует весь цикл ETL → Sim → Validate → Report через субагентов с формализованными hand-off'ами.

---

## 4. Критические наблюдения и предостережения

**Не переусложняй.** Исследование прямо предупреждает про «agent sprawl» — неконтролируемое размножение агентов. 5 ролей для проекта с 1–2 разработчиками — это потолок. Лучше 3 хорошо настроенных субагента, чем 8 плохо определённых.

**Human-in-the-loop обязателен.** В авиационной предметной области полная делегация — это путь к катастрофе. Каждое изменение бизнес-логики (br, oh, ll, статусы) должно проходить через тебя. Агенты ускоряют рутину, но не принимают доменные решения.

**Версионирование Skills.** Skills — это код, не документация. Они должны быть в git, меняться через PR, иметь changelog. Иначе через 3 месяца ты не будешь знать, какую версию «мозгов» использовал агент при конкретном коммите.

**Тестирование messaging.** Ветка `feature/flame-messaging` — это архитектурное изменение. Перед merge нужны: юнит-тесты на корректность передачи сообщений, интеграционные тесты на полный цикл симуляции, сравнение результатов с baseline (до messaging) на эталонном датасете.

**Документированный хардкод messaging.** Следуя политике проекта — все параметры messaging (размеры буферов, типы сообщений, стратегия коммуникации) должны быть в таблице хардкодов в README и в соответствующем SKILL.

---

## 5. Итог

Helicomponents — это проект с правильным фундаментом: чёткая предметная область, зрелая документация, продуманная архитектура данных и симуляции. Мультиагентный подход через Cursor 2.4 — это не «модное переделывание», а естественный следующий шаг для проекта с 514 коммитами и растущей сложностью.

Главная рекомендация: **начни с Skills, а не с субагентов**. Формализуй доменные знания в 3–5 файлов `SKILL.md`, и ты сразу увидишь, где Cursor начинает работать точнее. Субагенты — это второй шаг, когда Skills стабильны и проверены.

Ветка `feature/flame-messaging` — это ключевой момент для проекта. Messaging между агентами симуляции открывает путь к реалистичной модели каннибализации, динамического ремонта и управления флотом. Важно сделать это правильно с первого раза, потому что это фундамент для всей дальнейшей бизнес-логики.
