# Экспорт чата — 15-10-2025

Ключевые решения и изменения за сессию:

## Рефакторинг: Удаление избыточного чтения MP5 из states_stub

- **Проблема выявлена**: MP5 (суточные часы налёта `dt`/`dn`) читался во всех 5 функциях `states_stub`, но использовался только в `state_2_operations`.
- **Решение**: Полностью удалено чтение MP5 из `rtc_states_stub.py`:
  - Удалено из `state_1_inactive` (17 строк кода)
  - Удалено из `state_3_serviceable` (20 строк)
  - Удалено из `state_4_repair` (10 строк)
  - Удалено из `state_5_reserve` (20 строк)
  - Удалено из `state_6_storage` (14 строк)
  - **Итого**: -81 строк избыточного кода
- **Результат**: 
  - Производительность: 37.73с (улучшение ~40% vs 63с до оптимизации)
  - MP5 теперь читается ТОЛЬКО в `state_2_operations`, где он используется для инкрементов
  - Устранены потенциальные race conditions
  - Семантическая чистота: состояния `repair`/`storage`/`inactive` не зависят от налёта

## Валидация модуля count_ops (15.10.2025)

- **Тест**: state_2_operations + states_stub + count_ops на 3650 дней
- **Длительность**: 42.22с GPU, 10.2мс среднее время/шаг
- **Результат экспорта**: 1,018,350 строк в sim_masterv2 (детерминистично)

### Ключевые находки:

1. **"Истощение флота"** — постепенное уменьшение агентов с `intent=2`:
   - День 0: 154/154 агентов хотят остаться в operations (100%)
   - День 500: 140/154 (90.9%)
   - День 1500: 85/154 (55.2%)
   - День 3000: 2/154 (1.3%) — стабилизация
   - День 3649: 2/154 (1.3%)

2. **Распределение intent на день 3649**:
   - `intent=2`: 2 агента (хотят остаться)
   - `intent=4`: 97 агентов (хотят в ремонт, достигли OH)
   - `intent=6`: 55 агентов (хотят в хранение, достигли LL/BR)
   - **Вывод**: count_ops корректно считает ТОЛЬКО 2 агента, игнорируя 152

3. **Инварианты подтверждены** (SQL проверки):
   - ✅ Сумма intent = total (2+97+55=154)
   - ✅ count_ops ≤ total (на всех 3650 днях)
   - ✅ Агенты с intent≠2 не учитываются
   - ✅ Детерминизм (повторные прогоны идентичны)

### Вариант B vs Вариант A (исправление 10-10-2025):

**До (Вариант A — НЕПРАВИЛЬНО):**
```cpp
if (state == STATE_OPERATIONS) {
    ops_count[idx] = 1u;  // ❌ Считал ВСЕХ (включая intent=4/6)
}
```
- Проблема: На день 3649 считал 154 агента → баланс квот неверный

**После (Вариант B — ПРАВИЛЬНО):**
```cpp
if (state == STATE_OPERATIONS) {
    if (intent_state == 2u) {
        ops_count[idx] = 1u;  // ✅ Только желающих остаться
    } else {
        ops_count[idx] = 0u;  // ❌ Игнорирует intent=4/6
    }
}
```
- Исправление: На день 3649 считает 2 агента → баланс квот корректен

## Исправления логики triggers и inactive агентов

### 1. assembly_trigger в rtc_states_stub.py (state_4_repair):
- **Было**: `if (repair_days >= repair_time - assembly_time)` — триггер устанавливался многократно
- **Стало**: 
  ```cpp
  // Сброс прошлого триггера
  if (assembly_trigger == 1u) {
      FLAMEGPU->setVariable<unsigned int>("assembly_trigger", 0u);
  }
  // Установка нового триггера (один день)
  if (repair_days == repair_time - assembly_time) {
      FLAMEGPU->setVariable<unsigned int>("assembly_trigger", 1u);
  }
  ```
- **Результат**: Триггер активен ТОЛЬКО один день (окно сборки)

### 2. assembly_trigger в agent_population.py (при загрузке MP3):
- **Было**: `if repair_time - repair_days > assembly_time:` — неверная логика
- **Стало**: `if repair_time - repair_days < assembly_time:` — агент УЖЕ в фазе сборки
- **Результат**: На день 0 триггер устанавливается только для агентов в assembly phase

### 3. Логика inactive агентов в rtc_states_stub.py:
- **Было**: `if (step_day >= version_date + repair_time)` — неверная интерпретация
  - `step_day` = дни от начала симуляции (0-3649)
  - `version_date` = абсолютная дата (20273)
  - Условие никогда не выполнялось
- **Стало**: `if (step_day >= repair_time)` — прошло достаточно времени для ремонта
- **Результат**: Агенты в inactive корректно получают intent=2 после истечения repair_time

### 4. Удаление рудимента в state_2_operations:
- **Удалено**: 
  ```cpp
  if (assembly_trigger == 0u) {
      FLAMEGPU->setVariable<unsigned int>("assembly_trigger", 1u);
  }
  ```
- **Причина**: `assembly_trigger` семантически не связан с состоянием operations
- **Результат**: Триггер управляется ТОЛЬКО в состоянии repair

## Изменённые файлы

### Код (code/sim_v2/):
- **rtc_states_stub.py**: 
  - Удалено чтение MP5 из всех 5 функций (-81 строка)
  - Исправлена логика `assembly_trigger` (установка/сброс)
  - Исправлена логика inactive агентов (`step_day >= repair_time`)
- **rtc_state_2_operations.py**: 
  - Удалён рудимент установки `assembly_trigger=1`
- **components/agent_population.py**: 
  - Исправлен знак в условии `assembly_trigger` (`>` → `<`)

### Документация (docs/):
- **validation.md**: 
  - Добавлена секция "Валидация count_ops" (15.10.2025)
  - 4 инварианта с SQL запросами
  - Таблица динамики intent=2 по времени
  - Методология валидации (5 методов)
  - Ограничения изолированного тестирования
- **rtc_pipeline_architecture.md**: 
  - Обновлена секция "Детальная логика RTC функций" (без кода)
  - Удалены упоминания о чтении MP5 в states_stub
  - Обновлён инвариант "Минимализм операций"
- **README.md**: 
  - Обновлены ссылки на валидированные модули (count_ops 15.10)
- **count_ops_validation_15-10-2025.md** (НОВЫЙ): 
  - Полный отчёт по валидации (357 строк)
  - Конфигурация, результаты, инварианты, SQL запросы
  - Сравнение вариантов A и B
  - План следующих шагов

## Методология тестирования

### Поэтапная валидация модулей:
1. ✅ **state_2_operations** (13.10.2025)
2. ✅ **states_stub** (14.10.2025) — рефакторинг MP5 (15.10.2025)
3. ✅ **count_ops** (15.10.2025)
4. ⏳ **quota_ops_excess** — следующий для проверки

### Принципы валидации:
- **Только реальные данные** из ClickHouse (MP3/MP5)
- **SQL проверки** инвариантов в СУБД (никакого логирования в RTC)
- **Детерминизм** (повторные прогоны с --drop-table)
- **Длительность**: полный прогон 3650 дней для каждого модуля
- **Критерий успеха**: 0 нарушений инвариантов + код без временного логирования

## Инварианты states_stub (обновлено 15.10.2025)

### Общие инварианты:
1. **Минимализм операций**: MP5 НЕ читается в states_stub (только в state_2_operations)
2. **Один intent на агента**: Каждая функция устанавливает intent_state, не читая чужие
3. **Идемпотентность**: Повторный вызов не меняет результат (кроме счётчиков)
4. **Отсутствие race conditions**: Нет зависимости от порядка выполнения потоков

### Триггеры:
- **assembly_trigger**: Устанавливается на 1 день (`repair_days == repair_time - assembly_time`)
- **active_trigger**: Сбрасывается в state_2_operations после использования
- **partout_trigger**: Не используется в текущей версии

## Производительность

| Конфигурация | GPU | Строк MP2 | Комментарий |
|-------------|-----|-----------|-------------|
| state_2 + stub (до оптимизации) | ~63с | 1,018,350 | Базовый |
| state_2 + stub (после MP5 удаления) | 37.73с | 1,018,350 | **+40% ускорение** ✅ |
| state_2 + stub + count_ops | 42.22с | 1,018,350 | +4.5с (+11.9%) приемлемо |

## Следующие шаги

### Модуль #4: quota_ops_excess
**Цель**: Демонтаж избыточных агентов из operations → serviceable при превышении квоты.

**Зависимости**:
- ✅ state_2_operations — устанавливает intent
- ✅ states_stub — устанавливает intent для остальных состояний
- ✅ count_ops — подсчитывает баланс (mi8_ops_count/mi17_ops_count)
- ⏳ quota_ops_excess — использует count_ops для демоута (oldest first)

**План тестирования**:
1. Запустить: state_2 + stub + count_ops + quota_ops_excess
2. Проверить корректность демоута (oldest first по sne)
3. Валидировать через SQL: approve[idx] устанавливается правильно
4. Проверить, что количество демоутов не превышает excess

## Примечания

- Все изменения протестированы на реальных данных (MP3/MP5 из ClickHouse)
- Детерминизм подтверждён на всех этапах (1,018,350 строк стабильно)
- Код без временного логирования (критерий успеха выполнен)
- Документация синхронизирована: `.cursorrules` ↔ `validation.md` ↔ `README.md`

---

**Автор**: AI Agent (Claude Sonnet 4.5)  
**Дата**: 15 октября 2025  
**Версия**: V2 Modular Architecture (state-based)

