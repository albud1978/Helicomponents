### GPUarc: Архитектура спавна и прохождения этапов симуляции HELI (FLAME GPU)

Дата: 2025-09-06

### Область документа
- **Цель**: согласовать архитектуру спавна новых агентов (MI‑17) и их включения в общий конвейер симуляции от загрузки MP до экспорта.
- **Ограничения**: без изменения существующей логики статусов/квот; спавн — последний слой, новорождённые начинают «жить» с D+1.
- **Без кода**: документ описывает структуру, порядок операций и инварианты.

### Термины
- **MP1/MP4/MP5**: массивы среды FLAME GPU (MacroProperty/PropertyArray), загружаемые из ClickHouse.
- **FRAMES**: максимальная мощность кадров (размер популяции по осям индексов агентов) на весь горизонт.
- **DAYS**: число симулируемых суток.
- **D**: номер текущих суток; D0 — начальный день.

### Изменения в Extract (Condition precedent) — интерпретация месяца поставки
- Месяц поставки трактовать как 15‑е число месяца (не последний день):
  - При подготовке данных в ClickHouse заменить вычисление даты месяца поставки на mid‑month.

### Этап 0 — входные данные среды
- **MP1 (по индексу `mp1_idx_mi17_spawn` для `partseqno_i=70482`)**:
  - br_mi17, repair_time, partout_time, assembly_time, oh_mi17, ll_mi17, sne_new, ppr_new.
- **MP4**:
  - mp4_new_counter_mi17[day] — план рождения на сутки (агентов MI‑17).
- **MP5**:
  - daily_hours[(DAYS+1) × FRAMES] с паддингом D+1 (налёт по кадрам и дням) — уже содержит будущих агентов по полной мощности FRAMES.
- **Скалярные свойства**:
  - version_date, days_total, frames_total_max.
- **Служебные массивы среды**:
  - month_first_u32[day] — ordinal первого дня месяца (для mfg_date новорождённых).

### Этап 1 — мощность, индексация и порядок строк MP
- **FRAMES (фиксируется на старте)**:
  - FRAMES = |distinct aircraft_number| по объединению: MP3 ∪ MP5.
- **Порядок индексов (frames_index)**:
  - [исходные агенты в их текущем idx] + [все будущие номера, отсортированные по aircraft_number].
  - Формируем биекцию frames_index: aircraft_number → idx (для всех текущих и будущих).
- **Размерности MP**:
  - MP5 собирается по указанному порядку строк (FRAMES × (DAYS+1)).
  - MP2 (если включён) сразу создаётся размером (FRAMES × DAYS) с тем же порядком idx, что и MP5.

### Начальная популяция (старт модели)
- Создаём только агентов, присутствующих в MP3 (текущая популяция).
- Будущие номера из MP5 не создаём заранее: для них зарезервированы индексы в `frames_index`, строки MP5/MP2 подготовлены, но будут заполнены после спавна.

### Этап 2 — спавн (GPU‑only, atomicSub)
- На конце суток D RTC‑функция выполняет `atomicSub(mp4_new_counter_mi17[D], 1)` для каждого тикета и при `old>0` создаёт по одному агенту `agent_out`; `idx/psn/aircraft_number` берутся из device‑счётчиков; поля — по правилам ниже. См. раздел «GPU‑only спавн — условия (Condition precedent)».
- **Позиция**: слой спавна выполняется строго после логгера (новые в экспорт с D+1).

Примечание: если в MP5 есть номера, отсутствующие в MP3, они не создаются автоматически на старте. Они появятся только в тот день, когда `new_counter_mi17[D] > 0`.

### Этап 3 — порядок слоёв суток (общая модель)
1) Пролог дня: begin_day (сброс однодневных флагов у всех агентов).
2) Блок статусов: 6 → 4 → 2 (действующая логика начисления и переходов).
3) Квоты: intent → approve → apply → intent_clear; пост‑обработка статусов 3/5/1 (как в текущей модели).
4) Логгер MP2 (если включён) — в самом конце шага.
5) Спавн — самый последний слой (после логгера).

### Переменные агента HELI (фактически используемые) — для спавна
-- **Идентификация**
  - idx UInt16 — брать из frames_index[aircraft_number] (предварительно рассчитанное соответствие).
  - psn UInt32 — генерировать подряд на host, начиная с 2000000 (монотонный инкремент).
  - aircraft_number UInt32 — автоинкремент из диапазона ≥100000 по списку плановых поставок (уникальные, согласованные с frames_index).
  - ac_type_mask UInt8 — 64 (константа для MI‑17).
  - group_by UInt8 — 2 (MI‑17).
  - partseqno_i UInt32 — 70482 (MI‑17).
  - mfg_date UInt32 — начало месяца текущего D: month_first_u32[D].
- **Статус и счётчики**
  - status_id UInt32 — 3 (включение в очередь).
  - sne UInt32 — MP1.sne_new[mp1_idx_mi17_spawn].
  - ppr UInt32 — MP1.ppr_new[mp1_idx_mi17_spawn].
  - repair_days UInt32 — 0.
  - ops_ticket UInt32 — 0.
  - intent_flag UInt32 — 0 (выставляется позднее слоями intent для status_id=2).
- **Пороги/нормативы (из MP1 по mp1_idx_mi17_spawn)**
  - ll UInt32 — MP1.ll_mi17.
  - oh UInt32 — MP1.oh_mi17.
  - br UInt32 — MP1.br_mi17.
  - repair_time UInt16 — MP1.repair_time.
  - assembly_time UInt16 — MP1.assembly_time.
  - partout_time UInt16 — MP1.partout_time.
- **Суточные налёты**
  - daily_today_u32 UInt32 — выставляется штатным механизмом чтения MP5.
  - daily_next_u32 UInt32 — выставляется штатным механизмом чтения MP5.
  - Привязка к MP5: индекс строки \(row = D \times FRAMES + idx\); безопасный доступ к D+1 за счёт паддинга.
- **Триггеры (однодневные/даты)**
  - active_trigger UInt32 — 0.
  - assembly_trigger UInt32 — 0.
  - partout_trigger UInt32 — 0.

### Этап 4 — требования к массивам и границам
- MP5 — рассчитан на **FRAMES = frames_total_max** и горизонт DAYS, с паддингом D+1; размерность по idx определяется по distinct `aircraft_number` (MP3 ∪ MP5).
- MP2 (если включён) — размерностью (FRAMES × DAYS), с той же размерностью и порядком idx, что и MP5.
- Все слои, читающие по idx, обязаны использовать верхнюю границу FRAMES = frames_total_max.
- Отсутствуют «тихие пропуски»: при нехватке мощности или выходе за границы — аварийная остановка.

### Примечание — заполнение заранее подготовленных фреймов
- По мере рождения агентов RTC присваивает им `idx` через `atomicAdd(next_idx_spawn, 1u)` (согласованно с порядком строк MP5/frames_index); новые агенты начинают заполнять заранее подготовленные строки MP5/MP2.

### Этап 5 — экспорт
- Экспорт результатов (sim_results) выполняется штатным механизмом после завершения шага.
- Новорождённые попадают в экспорт начиная с D+1 (созданы после логгера D).
- Ключи экспорта: version_date, day_u16, idx, psn, aircraft_number и др. поля в соответствии с текущей схемой.

### Инварианты и типы
- Дневной объём рождения: born_today = mp4_new_counter_mi17[D] (для GPU‑варианта). 
- Учёт born_today — по выбранному способу спавна GPU‑atomic.
- Типы полей соответствуют требованиям производительности/точности (UInt8/16/32; без Float64).
- Спавн не влияет на квоты и не участвует в них напрямую; квоты — независимый путь.

### Проверки и валидация
- Сверка рождаемости по дням: Σ born_today == Σ mp4_new_counter_mi17[D].
- Включение новорождённых в слои D+1: контроль по переходам и MP2 (если включён).
- Границы индексации: idx < FRAMES, row < FRAMES × DAYS.

### Варианты реализации мощности FRAMES
- Базовый (принят): заранее резервировать frames_total_max по distinct (MP3 ∪ MP5); MP5/MP2 сразу на максимум.
- Альтернатива (не используем): динамическая ёмкость с хост‑мапами по aircraft_number.

### Открытые вопросы для согласования
- Точная политика инициализации sne/ppr: строго MP1.sne_new/ppr_new или допускаются модификаторы?
- Пороговые значения (ll/oh/br) — только по `mp1_idx_mi17_spawn` (70482) или нужны типовые профили?
- Стратегия при превышении FRAMES (исчерпание ёмкости): немедленный stop или отказ от рождения в текущие сутки?

### План следующего шага
- После утверждения: добавить слой спавна (последний), завести MacroProperty‑счётчики, подключить MP1/MP4/MP5, включить smoke‑валидацию рождения и обновить transform.md (правила спавна и инварианты).



### GPU‑only спавн (atomicSub)
Это основной и единственный поддерживаемый вариант спавна: полностью на GPU, без host‑батчей. Ниже — обязательные предварительные требования.

- Данные и размерности
  - FRAMES = distinct aircraft_number из MP3 ∪ MP5 (как в базовом варианте). Порядок строк MP5 фиксирован: [MP3] + [будущие из MP5 в порядке aircraft_number].
  - MP5 собран на (DAYS+1) × FRAMES; для будущих бортов строки уже присутствуют (но агенты будут созданы позже).
  - MP2 (если включён) подготовлен на FRAMES × DAYS.

- Свойства окружения (env) и MacroProperty (создаются до запуска симуляции)
  - days_total, version_date, frames_total (= FRAMES) заданы.
  - month_first_u32[day] доступен (PropertyArrayUInt32).
  - MP1‑массивы для 70482 готовы: br_mi17, ll_mi17, oh_mi17, repair_time, assembly_time, partout_time, sne_new, ppr_new; задан `mp1_idx_mi17_spawn`.
  - mp4_new_counter_mi17 — перевести в MacroPropertyUInt<DAYS> (а не только PropertyArray), чтобы был доступ к атомикам на device. Значения инициализируются из источника MP4.
  - Ввести MacroProperty‑счётчики (UInt32):
    - next_idx_spawn (init = frames_initial)
    - next_aircraft_no_mi17 (init = первый свободный ≥ 100000, согласованный с порядком будущих строк MP5)
    - next_psn_mi17 (init = первый свободный ≥ 2000000)

- Композиция модели (до запуска шага)
  - Добавить вспомогательный агент `spawn_ticket` (state=default) размером = FRAMES. Это «носитель» вызова RTC на каждом idx; бизнес‑логики в нём нет.
  - Одна RTC‑функция `rtc_spawn_mi17_atomic` на агенте `spawn_ticket` выполняется раз в сутки, в самом последнем слое:
    - читает `day = getStepCounter()`;
    - `old = atomicSub(mp4_new_counter_mi17, day, 1u)`; если `old > 0u` — создаёт ровно одного нового `component` через `agent_out`;
    - при создании инициализирует все поля по правилам этого документа; `idx = atomicAdd(next_idx_spawn, 1u)`; `psn/aircraft_number` из `atomicAdd(..)` соответствующих счётчиков;
    - mfg_date = month_first_u32[day]; MP1‑поля читаются по `mp1_idx_mi17_spawn`.
  - Слои: гарантировать размещение `rtc_spawn_mi17_atomic` строго после всех слоёв дня (после логгера, если хотим включать новорождённых с D+1).

- Инварианты и согласования
  - Порядок будущих строк в MP5 обязан совпадать с порядком генерации aircraft_number счётчиком `next_aircraft_no_mi17`, чтобы индексация idx ↔ aircraft_number оставалась согласованной.
  - next_idx_spawn по умолчанию растёт от `frames_initial` к FRAMES; при старте assert(next_idx_spawn ≤ FRAMES).
  - Суммарно за сутки родится столько агентов, сколько было в `mp4_new_counter_mi17[day]` (поскольку `spawn_ticket` имеет мощность ≥ этой величины при реальных масштабах FRAMES).
  - Seatbelts: dev=ON, prod=OFF. Типы строго UInt32/UInt16 как в правилах.


### План внедрения (по этапам)
1) Extract: даты и FRAMES
- Определить середину месяца поставки (15-е) в CH.
- Зафиксировать FRAMES = distinct aircraft_number из MP3 ∪ MP5; порядок: [MP3 idx] + [новые из MP5 ↑].
- MP5: (DAYS+1)×FRAMES; MP2 (если включён): FRAMES×DAYS.
- Тест: выборка месяцев (15-е), проверка distinct и порядка.

2) Подготовка окружения
- Прокинуть frames_total, days_total, version_date, month_first_u32.
- Перевести mp4_new_counter_mi17 → MacroPropertyUInt<DAYS>.
- Ввести MacroProperty-счётчики: next_idx_spawn (frames_initial), next_aircraft_no_mi17 (≥100000), next_psn_mi17 (≥2000000).
- Тест: прогон без спавна — без регрессий.

3) Каркас слоя спавна
- Агент `spawn_ticket` (|FRAMES|), пустая RTC-функция и слой строго после логгера.
- Тест: 7 дней — идентичен базе.

4) RTC: atomicSub (минимум)
- В ядре: `old = atomicSub(mp4_new_counter_mi17[day], 1u)`; при `old>0` — единичное `agent_out`; idx через `atomicAdd(next_idx_spawn,1u)`; временные константы.
- Тест: 10 дней, искусственный план — born == sum(new_counter).

5) Полная инициализация полей
- Подтянуть все поля из MP1 и константы; mfg_date = month_first_u32[day]; intent_flag=0; daily_*=0.
- Тест: 30 дней на реальных MP — валидация по выборке.

6) Интеграция и экспорт
- Полный прогон (например, 10 лет), экспорт; сверка Σ born и инвариантов.

7) Производительность/надёжность
- Seatbelts OFF в прод; защита от переполнения FRAMES; проверка JIT-кэша.

8) Документация
- Обновить transform.md (правила спавна), changelog.md; описать сценарии тестов.
