### GPUarc: Архитектура спавна и прохождения этапов симуляции HELI (FLAME GPU)

Дата: 2025-09-09

### Область документа
- **Цель**: согласовать архитектуру спавна новых агентов (MI‑17) и их включения в общий конвейер симуляции от загрузки MP до экспорта.
- **Ограничения**: без изменения существующей логики статусов/квот; спавн — последний слой, новорождённые начинают «жить» с D+1.
- **Без кода**: документ описывает структуру, порядок операций и инварианты.

### Термины
- **MP1/MP4/MP5**: массивы среды FLAME GPU (MacroProperty/PropertyArray), загружаемые из ClickHouse.
- **FRAMES**: максимальная мощность кадров (размер популяции по осям индексов агентов) на весь горизонт.
- **DAYS**: число симулируемых суток.
- **D**: номер текущих суток; D0 — начальный день.

### Фазы выполнения (по факту оркестрации)
- **Фаза 0 — симуляция (ежесуточный блок)**: выполняются все RTC слои статусов/квот/логгера и спавн. К host не обращаемся.
- **Фаза 2 — постпроцессинг (один раз после всех суток)**: выполняется только `rtc_mp2_postprocess`; остальные RTC выходят сразу.
- **Фаза 1 — экспорт (один батч после постпроцессинга)**: цикл по дням; на каждом d вызывается `rtc_mp2_copyout`, затем host читает и пишет батчами в БД. В конце возвращаемся на фазу 0.

### Изменения в Extract (Condition precedent) — интерпретация месяца поставки
- Месяц поставки трактовать как 15‑е число месяца (не последний день):
  - При подготовке данных в ClickHouse заменить вычисление даты месяца поставки на mid‑month.

### Этап 0 — входные данные среды
- **MP1 (по индексу `mp1_idx_mi17_spawn` для `partseqno_i=70482`)**:
  - br_mi17, repair_time, partout_time, assembly_time, oh_mi17, ll_mi17, sne_new, ppr_new.
- **MP4**:
  - mp4_new_counter_mi17[day] — план рождения на сутки (агентов MI‑17).
- **MP5**:
  - daily_hours[(DAYS+1) × FRAMES] с паддингом D+1 (налёт по кадрам и дням) — уже содержит будущих агентов по полной мощности FRAMES.
- **Скалярные свойства**:
  - version_date, days_total, frames_total_max.
- **Служебные массивы среды**:
  - month_first_u32[day] — ordinal первого дня месяца (для mfg_date новорождённых).

### Этап 1 — мощность, индексация и порядок строк MP
- **FRAMES (фиксируется на старте)**:
  - FRAMES = |distinct aircraft_number| по объединению: MP3 ∪ MP5.
- **Порядок индексов (frames_index)**:
  - [исходные агенты в их текущем idx] + [все будущие номера, отсортированные по aircraft_number].
  - Формируем биекцию frames_index: aircraft_number → idx (для всех текущих и будущих).
- **Размерности MP**:
  - MP5 собирается по указанному порядку строк (FRAMES × (DAYS+1)).
  - MP2 (если включён) сразу создаётся размером (FRAMES × DAYS) с тем же порядком idx, что и MP5.

### Начальная популяция (старт модели)
- Создаём только агентов, присутствующих в MP3 (текущая популяция).
- Будущие номера из MP5 не создаём заранее: для них зарезервированы индексы в `frames_index`, строки MP5/MP2 подготовлены, но будут заполнены после спавна.

### Этап 2 — спавн (GPU‑only, менеджер + тикеты)
- На конце суток D выполняется два слоя:
  1) `rtc_spawn_mgr` (1 агент) читает план `mp4_new_counter_mi17_seed[day]`, ограничивает по `frames_total`, публикует скаляры MacroProperty: `spawn_need_u32`, `spawn_base_idx_u32`, `spawn_base_acn_u32`, `spawn_base_psn_u32`, и сдвигает локальные `next_*`.
  2) `rtc_spawn_ticket` (K тикетов, у нас K=16): для `ticket=k`, если `k < spawn_need_u32`, создаёт ровно одного `component` через `agent_out`, заполняя поля по правилам ниже.
- Используются именно скалярные MacroProperty (не массивы) для совместимости с текущим PyFLAMEGPU.
- **Позиция**: блок спавна выполняется строго последним, после логгера (новорождённые входят в расчёты с D+1 и в экспорт попадают начиная с D+1).

Примечание: если в MP5 есть номера, отсутствующие в MP3, они не создаются автоматически на старте. Они появятся только в тот день, когда `new_counter_mi17[D] > 0`.

### Этап 3 — порядок слоёв суток (общая модель)
1) Пролог дня: begin_day (сброс однодневных флагов у всех агентов).
2) Блок статусов: 6 → 4 → 2 (действующая логика начисления и переходов).
3) Квоты: intent → approve → apply → intent_clear; пост‑обработка статусов 3/5/1 (как в текущей модели).
4) Логгер MP2 (если включён) — в самом конце шага.
5) Спавн — самый последний слой (после логгера).

#### Таблица: последовательность слоёв внутри суток (phase=0)

| № | Слой / RTC | Назначение | Примечания |
|---|---|---|---|
| 1 | rtc_probe_mp5 | Заполнить dt/dn из MP5 | Включён всегда в полной сборке |
| 2 | rtc_quota_begin_day | Обнулить ops_ticket, intent_flag и все триггеры | Утренний сброс |
| 3 | rtc_status_6 | Логика статуса 6 | |
| 4 | rtc_status_4 | Логика статуса 4 | |
| 5 | rtc_status_2 | Начисления и пороги LL/OH/BR | Требует dt/dn |
| 6 | rtc_quota_intent | Intent для S2 | |
| 7 | rtc_quota_approve_manager | Распределение для S2 | Один менеджер |
| 8 | rtc_quota_apply | Проставить ops_ticket | По approve буферам |
| 9 | rtc_quota_intent_clear | Очистить intent‑буферы | Не трогает флаги агента |
| 10 | rtc_quota_intent_s3 → approve_s3 → apply → intent_clear → rtc_status_3_post_quota | Квоты для S3 и переход 3→2 | Остаток от S2 |
| 11 | rtc_quota_intent_s5 → approve_s5 → apply → intent_clear | Квоты для S5 | |
| 12 | rtc_quota_intent_s1 → approve_s1 → apply → intent_clear → rtc_status_1_post_quota | Квоты для S1 и переход 1→2 | Политика по mfg_date |
| 13 | rtc_status_5_post_quota → rtc_status_2_post_quota | Финальные переходы | Исключить двойные переходы |
| 14 | rtc_log_day | Запись дня в MP2 (agent_out) | Перед спавном |
| 15 | rtc_spawn_mgr → rtc_spawn_ticket | Рождение новых HELI | Всегда последним |

### Минимальная интеграция спавна в существующую модель (без изменения остальной логики)
- Объявить новые сущности в модели:
  - Агент `spawn_ticket` с переменной `ticket UInt32` (значения 0..K−1; K=16 достаточно для нашего сценария и тестов).
  - Агент `spawn_mgr` с переменными `next_idx UInt32`, `next_acn UInt32`, `next_psn UInt32` (менеджер генерации ID).
  - Свойства окружения (если ещё не объявлены):
    - `mp4_new_counter_mi17_seed[day]` (PropertyArrayUInt32) — план рождения (из MP4).
    - `month_first_u32[day]` (PropertyArrayUInt32) — первый день месяца (для mfg_date).
    - `mp1_idx_mi17_spawn` (UInt) — индекс строки MP1 для `partseqno_i=70482`.
    - MacroProperty по дням (UInt32): `spawn_need_u32`, `spawn_base_idx_u32`, `spawn_base_acn_u32`, `spawn_base_psn_u32`.
    - MacroProperty‑счётчики (UInt32, длина=1): `next_idx_spawn`, `next_aircraft_no_mi17`, `next_psn_mi17`.
- RTC‑функции:
  - `rtc_spawn_mgr` (на `spawn_mgr`): читает `need = mp4_new_counter_mi17_seed[day]`, публикует `need` и базовые ID в MacroProperty по текущему дню; локально инкрементирует `next_*`.
  - `rtc_spawn_mi17_atomic` (на `spawn_ticket`): для каждого `ticket=k`, если `k < need[day]`, создаёт одного `component` через `agent_out` и инициализирует поля по спецификации проекта.
- Порядок слоёв:
  - Добавить `lyr_spawn_mgr` сразу перед самым последним слоем.
  - Добавить `lyr_spawn` строго последним (после логгера), чтобы новорождённые участвовали в симуляции с D+1.
- Критично: включить `setAgentOutput("component")` на мутируемом дескрипторе RTC (`spawn_ticket.newRTCFunction(...)`).

### Совместимость с рабочей моделью без спавна
- При `mp4_new_counter_mi17_seed[day] == 0` спавн не создаёт агентов; весь остальной конвейер остаётся неизменным.
- Слои статусов, квоты и логгер не меняются; добавление двух слоёв спавна в конец не влияет на «без спавна» режим.
- FRAMES и MP5 должны быть заранее рассчитаны под будущих агентов; выход за границы недопустим.

### Переменные агента HELI (фактически используемые) — для спавна
-- **Идентификация**
  - idx UInt16 — брать из frames_index[aircraft_number] (предварительно рассчитанное соответствие).
  - psn UInt32 — генерировать подряд на host, начиная с 2000000 (монотонный инкремент).
  - aircraft_number UInt32 — автоинкремент из диапазона ≥100000 по списку плановых поставок (уникальные, согласованные с frames_index).
  - ac_type_mask UInt8 — 64 (константа для MI‑17).
  - group_by UInt8 — 2 (MI‑17).
  - partseqno_i UInt32 — 70482 (MI‑17).
  - mfg_date UInt32 — начало месяца текущего D: month_first_u32[D].
- **Статус и счётчики**
  - status_id UInt32 — 3 (включение в очередь).
  - sne UInt32 — MP1.sne_new[mp1_idx_mi17_spawn].
  - ppr UInt32 — MP1.ppr_new[mp1_idx_mi17_spawn].
  - repair_days UInt32 — 0.
  - ops_ticket UInt32 — 0.
  - intent_flag UInt32 — 0 (выставляется позднее слоями intent для status_id=2).
- **Пороги/нормативы (из MP1 по mp1_idx_mi17_spawn)**
  - ll UInt32 — MP1.ll_mi17.
  - oh UInt32 — MP1.oh_mi17.
  - br UInt32 — MP1.br_mi17.
  - repair_time UInt16 — MP1.repair_time.
  - assembly_time UInt16 — MP1.assembly_time.
  - partout_time UInt16 — MP1.partout_time.
- **Суточные налёты**
  - daily_today_u32 UInt32 — выставляется штатным механизмом чтения MP5.
  - daily_next_u32 UInt32 — выставляется штатным механизмом чтения MP5.
  - Привязка к MP5: индекс строки \(row = D \times FRAMES + idx\); безопасный доступ к D+1 за счёт паддинга.
- **Триггеры (однодневные/даты)**
  - active_trigger UInt32 — 0.
  - assembly_trigger UInt32 — 0.
  - partout_trigger UInt32 — 0.

### Этап 4 — требования к массивам и границам
- MP5 — рассчитан на **FRAMES = frames_total_max** и горизонт DAYS, с паддингом D+1; размерность по idx определяется по distinct `aircraft_number` (MP3 ∪ MP5).
- MP2 (если включён) — размерностью (FRAMES × DAYS), с той же размерностью и порядком idx, что и MP5.
- Все слои, читающие по idx, обязаны использовать верхнюю границу FRAMES = frames_total_max.
- Отсутствуют «тихие пропуски»: при нехватке мощности или выходе за границы — аварийная остановка.

### Примечание — заполнение заранее подготовленных фреймов
- По мере рождения агентов RTC присваивает им `idx` через `atomicAdd(next_idx_spawn, 1u)` (согласованно с порядком строк MP5/frames_index); новые агенты начинают заполнять заранее подготовленные строки MP5/MP2.

### Этап 5 — экспорт
- Экспорт результатов (sim_results) выполняется штатным механизмом после завершения шага.
- Новорождённые попадают в экспорт начиная с D+1 (созданы после логгера D).
- Ключи экспорта: version_date, day_u16, idx, psn, aircraft_number и др. поля в соответствии с текущей схемой.

### Инварианты и типы
- Дневной объём рождения: born_today = mp4_new_counter_mi17[D] (для GPU‑варианта). 
- Учёт born_today — по выбранному способу спавна GPU‑atomic.
- Типы полей соответствуют требованиям производительности/точности (UInt8/16/32; без Float64).
- Спавн не влияет на квоты и не участвует в них напрямую; квоты — независимый путь.

### Проверки и валидация
- Сверка рождаемости по дням: Σ born_today == Σ mp4_new_counter_mi17[D].
- Включение новорождённых в слои D+1: контроль по переходам и MP2 (если включён).
- Границы индексации: idx < FRAMES, row < FRAMES × DAYS.

### Варианты реализации мощности FRAMES
- Базовый (принят): заранее резервировать frames_total_max по distinct (MP3 ∪ MP5); MP5/MP2 сразу на максимум.
- Альтернатива (не используем): динамическая ёмкость с хост‑мапами по aircraft_number.

### Открытые вопросы для согласования
- Точная политика инициализации sne/ppr: строго MP1.sne_new/ppr_new или допускаются модификаторы?
- Пороговые значения (ll/oh/br) — только по `mp1_idx_mi17_spawn` (70482) или нужны типовые профили?
- Стратегия при превышении FRAMES (исчерпание ёмкости): немедленный stop или отказ от рождения в текущие сутки?

### План следующего шага
- После утверждения: добавить слой спавна (последний), завести MacroProperty‑счётчики, подключить MP1/MP4/MP5, включить smoke‑валидацию рождения и обновить transform.md (правила спавна и инварианты).



### GPU‑only спавн (менеджер + тикеты)
Это основной и единственный поддерживаемый вариант спавна: полностью на GPU, без host‑батчей. Ниже — обязательные предварительные требования.

- Данные и размерности
  - FRAMES = distinct aircraft_number из MP3 ∪ MP5 (как в базовом варианте). Порядок строк MP5 фиксирован: [MP3] + [будущие из MP5 в порядке aircraft_number].
  - MP5 собран на (DAYS+1) × FRAMES; для будущих бортов строки уже присутствуют (но агенты будут созданы позже).
  - MP2 (если включён) подготовлен на FRAMES × DAYS.

- Свойства окружения (env) и MacroProperty (создаются до запуска симуляции)
  - days_total, version_date, frames_total (= FRAMES) заданы.
  - month_first_u32[day] доступен (PropertyArrayUInt32).
  - MP1‑массивы для 70482 готовы: br_mi17, ll_mi17, oh_mi17, repair_time, assembly_time, partout_time, sne_new, ppr_new; задан `mp1_idx_mi17_spawn`.
  - mp4_new_counter_mi17_seed — PropertyArrayUInt32; внутри шага используется менеджером как источник плана. Отдельный MacroProperty‑массив по дням не требуется.
  - Ввести MacroProperty‑счётчики (UInt32):
    - next_idx_spawn (init = frames_initial)
    - next_aircraft_no_mi17 (init = первый свободный ≥ 100000, согласованный с порядком будущих строк MP5)
    - next_psn_mi17 (init = первый свободный ≥ 2000000)

- Композиция модели (до запуска шага)
  - Добавить вспомогательный агент `spawn_ticket` (state=default) размером = FRAMES. Это «носитель» вызова RTC на каждом idx; бизнес‑логики в нём нет.
  - Одна RTC‑функция `rtc_spawn_mi17_atomic` на агенте `spawn_ticket` выполняется раз в сутки, в самом последнем слое:
    - читает `day = getStepCounter()`;
    - `old = atomicSub(mp4_new_counter_mi17, day, 1u)`; если `old > 0u` — создаёт ровно одного нового `component` через `agent_out`;
    - при создании инициализирует все поля по правилам этого документа; `idx = atomicAdd(next_idx_spawn, 1u)`; `psn/aircraft_number` из `atomicAdd(..)` соответствующих счётчиков;
    - mfg_date = month_first_u32[day]; MP1‑поля читаются по `mp1_idx_mi17_spawn`.
  - Слои: гарантировать размещение `rtc_spawn_mi17_atomic` строго после всех слоёв дня (после логгера, чтобы новорождённые включались с D+1).

Примечание: актуальная реализация использует паттерн «менеджер + тикеты» для обхода ограничения «1 агент на один вызов RTC». Вариант с единым `atomicSub` на счётчике дня эквивалентен по эффекту и может рассматриваться альтернативой, не меняя позицию слоя спавна.

- Инварианты и согласования
  - Порядок будущих строк в MP5 обязан совпадать с порядком генерации aircraft_number счётчиком `next_aircraft_no_mi17`, чтобы индексация idx ↔ aircraft_number оставалась согласованной.
  - next_idx_spawn по умолчанию растёт от `frames_initial` к FRAMES; при старте assert(next_idx_spawn ≤ FRAMES).
  - Суммарно за сутки родится столько агентов, сколько было в `mp4_new_counter_mi17[day]` (поскольку `spawn_ticket` имеет мощность ≥ этой величины при реальных масштабах FRAMES).
  - Seatbelts: dev=ON, prod=OFF. Типы строго UInt32/UInt16 как в правилах.


### План внедрения (по этапам)
1) Extract: даты и FRAMES
- Определить середину месяца поставки (15-е) в CH.
- Зафиксировать FRAMES = distinct aircraft_number из MP3 ∪ MP5; порядок: [MP3 idx] + [новые из MP5 ↑].
- MP5: (DAYS+1)×FRAMES; MP2 (если включён): FRAMES×DAYS.
- Тест: выборка месяцев (15-е), проверка distinct и порядка.

2) Подготовка окружения
- Прокинуть frames_total, days_total, version_date, month_first_u32.
- Перевести mp4_new_counter_mi17 → MacroPropertyUInt<DAYS>.
- Ввести MacroProperty-счётчики: next_idx_spawn (frames_initial), next_aircraft_no_mi17 (≥100000), next_psn_mi17 (≥2000000).
- Тест: прогон без спавна — без регрессий.

3) Каркас слоя спавна
- Агент `spawn_ticket` (|FRAMES|), пустая RTC-функция и слой строго после логгера.
- Тест: 7 дней — идентичен базе.

4) RTC: менеджер + тикеты (минимум)
- Менеджер публикует `need/base_*` в скалярные MacroProperty, тикеты создают по одному HELI при `k < need`.
- Тест: 10 дней, искусственный план — born == sum(new_counter).

5) Полная инициализация полей
- Подтянуть все поля из MP1 и константы; mfg_date = month_first_u32[day]; intent_flag=0; daily_*=0.
- Тест: 30 дней на реальных MP — валидация по выборке.

6) Интеграция и экспорт
- Полный прогон (например, 10 лет), экспорт; сверка Σ born и инвариантов.

7) Производительность/надёжность
- Seatbelts OFF в прод; защита от переполнения FRAMES; проверка JIT-кэша.

8) Документация
- Обновить transform.md (правила спавна), changelog.md; описать сценарии тестов.

### Команды запуска
- Режим А: симуляция без спавна (проверка базовой логики статусов/квот/экспорта)
  - 365 суток (seatbelts off), экспорт выключен:
    ```bash
    PYTHONUNBUFFERED=1 HL_ENABLE_MP2=0 HL_ENABLE_MP2_POST=0 \
    python3 -u code/sim_master.py \
      --status12456-smoke-real --status12456-days 365 \
      --export-sim off --export-truncate \
      --export-d0 off --export-postprocess off \
      --seatbelts off
    ```
  - 3650 суток (10 лет) с экспортом (пример из практики):
    ```bash
    LOG=logs/sim_$(date +%Y%m%d_%H%M%S).log; mkdir -p logs;
    PYTHONUNBUFFERED=1 HL_ENABLE_MP2=1 HL_ENABLE_MP2_POST=0 \
    python3 -u code/sim_master.py \
      --status12456-smoke-real --status12456-days 3650 \
      --export-sim on --export-truncate \
      --export-d0 off --export-postprocess off \
      --seatbelts off 2>&1 | tee "$LOG" | cat
    ```

- Режим B (deprecated): отдельный spawn‑smoke. Не используется в прод‑сценариях; оставлен только для низкоуровневой диагностики JIT.
