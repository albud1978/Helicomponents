# Анализ архитектуры переходов состояний

## Текущая проблема

В FLAME GPU есть ограничения на функции в одном слое:
- Функции не могут иметь общее выходное состояние (например, `1->2`, `3->2`, `5->2` все пишут в состояние 2)
- Функции не могут иметь общее входное состояние (например, `2->4`, `2->6` обе читают из состояния 2)

## Наши переходы состояний

```
1 (inactive) -> 2 (operations)
2 (operations) -> 4 (repair)
2 (operations) -> 6 (storage)
3 (serviceable) -> 2 (operations)
4 (repair) -> 5 (reserve) 
5 (reserve) -> 2 (operations)
6 (storage) -> 6 (storage) [остаётся]
```

## Конфликты

1. **Общее выходное состояние 2 (operations)**:
   - `1->2`, `3->2`, `5->2` - все пишут в operations
   
2. **Общее входное состояние 2 (operations)**:
   - `2->4`, `2->6` - обе читают из operations

## Возможные решения

### 1. Разделение по слоям (текущая попытка)
Проблема: даже в разных слоях функции с общим выходным состоянием конфликтуют.

### 2. Использование промежуточных состояний
Например:
- `1->pending_operations`
- `3->pending_operations`
- `5->pending_operations`
- `pending_operations->operations` (одна функция)

### 3. Использование функций без изменения состояния
- RTC функции устанавливают `intent_state`
- Отдельный механизм (не через setEndState) применяет переходы

### 4. Последовательная обработка
- Сначала обрабатываем все переходы в operations
- Потом обрабатываем переходы из operations
- И так далее

## Вопросы к FLAME GPU сообществу

1. Как правильно организовать множественные переходы в одно состояние?
2. Можно ли изменять состояние агента программно, а не через setEndState?
3. Есть ли примеры сложных state machines в FLAME GPU?
