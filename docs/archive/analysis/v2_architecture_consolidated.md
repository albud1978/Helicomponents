# V2 State-based Architecture (Консолидированный документ)

## Дата создания: 2024-12-22

## Оглавление
1. [Основные принципы](#основные-принципы)
2. [Архитектура States](#архитектура-states)
3. [Микросервисная структура](#микросервисная-структура)
4. [Порядок выполнения](#порядок-выполнения)
5. [Важные архитектурные решения](#важные-архитектурные-решения)
6. [Результаты и преимущества](#результаты-и-преимущества)
7. [Следующие шаги](#следующие-шаги)

---

## Основные принципы

### 1. Переход на FLAME GPU States

**Было (V1):**
- Переменная `status_id` (0,1,2,3,4,5,6)
- Все агенты выполняют все функции
- Проверка статуса внутри каждой RTC функции
- Warp divergence из-за ветвлений

**Стало (V2):**
- Агенты находятся в состояниях (states)
- Функции привязаны к конкретным состояниям
- GPU автоматически фильтрует агентов
- Оптимальное использование GPU

### 2. Разделение логики изменения состояния

**Было:**
- Каждая RTC функция может менять status_id
- Дублирование логики квотирования
- Сложные зависимости между функциями

**Стало:**
- RTC функции статусов только устанавливают intent флаги
- Централизованное квотирование
- Единая функция переходов состояний

### 3. Микросервисная архитектура

**Было:**
- Монолитный sim_master.py (2000+ строк)
- Сложность модификации и тестирования

**Стало:**
- Модульная структура с отдельными компонентами
- Оркестратор для управления симуляцией
- Легкая расширяемость

---

## Архитектура States

### Основные состояния (соответствуют status_id):
- `state_1` - Неактивный (inactive)
- `state_2` - Эксплуатация (operations)  
- `state_3` - Исправен
- `state_4` - Ремонт
- `state_5` - Резерв (reserve)
- `state_6` - Хранение

### Ключевая переменная агента:
```python
# intent_state: unsigned int - номер желаемого состояния
- 0 = нет намерений (детерминированный переход выполнен)
- 1 = намерение стать неактивным (не используется)
- 2 = намерение перейти в эксплуатацию (operations)
- 3 = намерение перейти в исправен
- 4 = намерение перейти в ремонт (не используется - детерминированный)
- 5 = намерение перейти в резерв (не используется - детерминированный)
- 6 = намерение перейти в хранение (не используется - детерминированный)

# Правила использования:
- Устанавливается в RTC функциях состояний
- intent_state = 0 после любого детерминированного перехода
- intent_state != 0 только для квотированных переходов
- Менеджер состояний обрабатывает только агентов с intent_state != 0
```

---

## Микросервисная структура

### Файловая организация:
```
code/sim_v2/
├── base_model.py               # Базовая модель с окружением
├── orchestrator_v2.py          # Оркестратор симуляции
├── rtc_mp5_probe.py           # Модуль работы с MP5
├── rtc_state_1_inactive.py     # Логика неактивных агентов
├── rtc_state_2_operations.py   # Логика эксплуатации
├── rtc_state_3_serviceable.py  # Логика исправен
├── rtc_state_4_repair.py       # Логика ремонт
├── rtc_state_5_reserve.py      # Логика резерва
├── rtc_state_6_storage.py      # Логика хранение
├── rtc_quota_manager.py        # Централизованное квотирование
└── rtc_state_transitions.py    # Переходы между состояниями
```

### Ключевые компоненты:

#### 1. base_model.py
- Определяет окружение (Environment)
- Создает описание агентов
- Инициализирует MacroProperty для MP5
- Загружает константы и массивы

#### 2. orchestrator_v2.py
```python
class V2Orchestrator:
    def __init__(self, env_data):
        self.env_data = env_data
        self.base_model = BaseModel(env_data)
        
    def build_model(self, modules: List[str]):
        # Динамическая загрузка RTC модулей
        for module_name in modules:
            self._add_rtc_module(module_name)
            
    def create_simulation(self):
        # Создание симуляции и популяции агентов
        
    def run(self, steps: int):
        # Запуск симуляции
```

#### 3. RTC модули
Каждый модуль экспортирует функцию `register_rtc(model, agent)`:
```python
def register_rtc(model, agent):
    rtc_src = """
    FLAMEGPU_AGENT_FUNCTION(rtc_state_X, ...) {
        // Логика для конкретного состояния
    }
    """
    agent.newRTCFunction("rtc_state_X", rtc_src)
    # Добавление в соответствующий слой модели
```

---

## Порядок выполнения

### На каждом степе симуляции:

#### Слой 0: Инициализация MP5 (только step=0)
- **HostFunction** загружает MP5 данные в MacroProperty
- Выполняется один раз в начале симуляции
- Полностью изолирован от логики статусов

#### Слой 1: Параллельная обработка состояний
- Все `rtc_state_X` функции в одном слое
- GPU автоматически фильтрует по состояниям
- Функции выполняются параллельно для разных состояний
- Каждая функция:
  - Обновляет наработки (sne, ppr, repair_days)
  - Проверяет условия переходов
  - Устанавливает intent флаги
  - НЕ меняет состояние

#### Слой 2: Единый менеджер состояний
- **Функция**: `rtc_state_manager`
- **Обрабатывает**: всех агентов с `intent_state != 0`
- **Логика**:
  1. Собирает все намерения перехода в state_2
  2. Распределяет квоты `ops_counter` для intent_state = 2
  3. Применяет переходы:
     - С квотой: state = 2
     - Без квоты (если был в state_2): state = 3
     - Остальные intent: прямой переход state = intent_state
  4. Сбрасывает intent_state = 0 для следующего шага
- **Преимущества**: один проход, без множественных функций квотирования

### Важно: Обработка немедленных и отложенных переходов

**Проблема**: Часть переходов детерминирована (2→6 при превышении ll), часть зависит от квот (3→2).

**Финальное решение**: Архитектура с intent_state

После анализа FLAME GPU и проблемы двойных переходов найдено элегантное решение:

**Ключевая идея**: Использовать `intent_state` как номер желаемого состояния вместо бинарных флагов.

**Архитектура**:

1. **Детерминированные переходы** - выполняются немедленно в RTC функциях:
   - state_2 → state_6 (превышен ll или oh+br)
   - state_2 → state_4 (превышен oh, но br не превышен)  
   - state_4 → state_5 (завершен ремонт)
   - При переходе: `intent_state = 0` (нет дальнейших намерений)

2. **Переходы с намерением** - устанавливают intent_state:
   - state_1,3,5: `intent_state = 2` (хочу в эксплуатацию)
   - state_2: `intent_state = 2` если есть квота, иначе `intent_state = 3`
   - state_0,4,6: `intent_state = 0` (нет намерений)

3. **Единый менеджер состояний** (вместо множества функций квотирования):
   - Обрабатывает всех агентов с `intent_state != 0`
   - Распределяет квоты ops_counter для `intent_state = 2`
   - Применяет переходы: `state = intent_state` (с учетом квот)
   - Один проход по массиву, без передачи остатков

**Преимущества**:
- Решает проблему двойных переходов (4→5→2 невозможен)
- Упрощает архитектуру (один менеджер вместо многих)
- Универсальный механизм для всех переходов
- Эффективная обработка на GPU

**Приоритеты переходов** (в единой функции):
1. Критические (wants_writeoff) - высший приоритет
2. Детерминированные (wants_repair) - средний приоритет  
3. Квотированные (has_ops_ticket) - низший приоритет

**Гарантии FLAME GPU**:
- Синхронизация между слоями (барьер)
- Отсутствие race conditions при правильной архитектуре
- Детерминированность результатов

**Пример реализации с intent_state**:

```cuda
// В rtc_state_2 - обработка эксплуатации
FLAMEGPU_AGENT_FUNCTION(rtc_state_2, ...) {
    if (state != 2) return flamegpu::ALIVE;
    
    // Обновление наработок
    sne += dt;
    ppr += dt;
    
    // Детерминированные переходы (немедленно)
    if (sne + dn >= ll) {
        FLAMEGPU->setVariable("state", 6u);
        FLAMEGPU->setVariable("s6_started", 1u);
        FLAMEGPU->setVariable("intent_state", 0u);  // Нет дальнейших намерений
        return flamegpu::ALIVE;
    }
    
    if (ppr + dn >= oh) {
        if (sne + dn >= br) {
            FLAMEGPU->setVariable("state", 6u);
            FLAMEGPU->setVariable("s6_started", 1u);
        } else {
            FLAMEGPU->setVariable("state", 4u);
            FLAMEGPU->setVariable("repair_days", 1u);
        }
        FLAMEGPU->setVariable("intent_state", 0u);  // Нет дальнейших намерений
        return flamegpu::ALIVE;
    }
    
    // Если остался в статусе 2 - намерение продолжить эксплуатацию
    FLAMEGPU->setVariable("intent_state", 2u);
    return flamegpu::ALIVE;
}

// В rtc_state_5 - обработка хранения
FLAMEGPU_AGENT_FUNCTION(rtc_state_5, ...) {
    if (state != 5) return flamegpu::ALIVE;
    
    // Хочу вернуться в эксплуатацию
    FLAMEGPU->setVariable("intent_state", 2u);
    return flamegpu::ALIVE;
}

// Единый менеджер состояний (вместо множества функций квотирования)
FLAMEGPU_AGENT_FUNCTION(rtc_state_manager, ...) {
    const unsigned int intent = FLAMEGPU->getVariable<unsigned int>("intent_state");
    
    if (intent == 0u) return flamegpu::ALIVE;  // Нет намерений
    
    if (intent == 2u) {
        // Проверка квоты для перехода в эксплуатацию
        const unsigned int ops_remaining = FLAMEGPU->environment.getProperty<unsigned int>("ops_quota_remaining");
        if (ops_remaining > 0u) {
            FLAMEGPU->setVariable("state", 2u);
            // Уменьшение квоты происходит в другом месте
        } else {
            // Нет квоты - переход в исправен (для тех кто был в state 2)
            if (FLAMEGPU->getVariable<unsigned int>("state") == 2u) {
                FLAMEGPU->setVariable("state", 3u);
            }
        }
    } else {
        // Для других intent - прямой переход
        FLAMEGPU->setVariable("state", intent);
    }
    
    // Сброс intent для следующего шага
    FLAMEGPU->setVariable("intent_state", 0u);
    return flamegpu::ALIVE;
}
```

---

## Важные архитектурные решения

### 1. MacroProperty для MP5
- Размер: 286 frames × 4001 days = 1,144,286 элементов
- PropertyArray ограничен ~10K элементами
- Инициализация через HostFunction:

```python
class HF_InitMP5(fg.HostFunction):
    def run(self, FLAMEGPU):
        mp = FLAMEGPU.environment.getMacroPropertyUInt32("mp5_lin")
        for d in range(self.days + 1):
            for f in range(self.frames):
                src_idx = d * self.frames + f
                dst_idx = d * MAX_FRAMES + f
                if src_idx < len(self.data):
                    mp[dst_idx] = self.data[src_idx]
```

### 2. Фиксированные размеры
- `MAX_FRAMES` - определяется из данных MP3/MP5
- `MAX_DAYS = 4000` - фиксированный буфер
- `MAX_SIZE = MAX_FRAMES * (MAX_DAYS + 1)`
- Обеспечивает единообразную компиляцию RTC

### 3. Обработка статуса 6 (хранение)
**Для изначально в хранении (`s6_started = 0`):**
- RTC функция выходит без изменений
- Гарантирует неизменность всех переменных
- **Не участвуют в квотировании**

**Для перешедших в статус 6 (`s6_started = 1`):**
- Счетчик дней до `partout_time`
- Триггер для снятия агрегатов с планера
- Важно для multiBOM архитектуры

**Ключевое уточнение**:
- Сохранение статуса (6→6) ≠ получение нового статуса
- Агенты в статусе 6 никогда не участвуют в квотировании
- Детерминированные переходы (2→6, 4→5) исключают агента из квотирования в этом шаге

### 4. Assembly trigger при инициализации
**Проблема:** Агенты в статусе 4 на начало симуляции
**Решение:** При создании проверять:
```python
if status_id == 4 and (repair_time - repair_days > assembly_time):
    assembly_trigger = 1  # Сигнал для сборки агрегатов
```

### 5. Загрузка OH при создании агентов
- Из MP1: `oh_mi8` для group_by=1, `oh_mi17` для group_by=2
- Убирает необходимость определять в RTC
- Упрощает и ускоряет RTC логику

### 6. Фильтрация планеров
- Загружаются ВСЕ ~7113 строк из heli_pandas
- Агентами становятся только планеры (group_by ∈ {1,2})
- ~286 активных агентов
- Остальные данные доступны для справки

---

## Результаты и преимущества

### Технические преимущества:
1. **Эффективность GPU**:
   - Нет warp divergence
   - Оптимальное использование кеша
   - Параллельное выполнение по состояниям

2. **Производительность**:
   - Функции выполняются только для нужных агентов
   - Централизованное квотирование без атомарных операций
   - Фиксированные размеры для единообразной компиляции

### Архитектурные преимущества:
1. **Модульность**:
   - Каждый аспект в отдельном файле
   - Легко добавить новые состояния
   - Простое тестирование компонентов

2. **Расширяемость**:
   - Динамическая загрузка модулей
   - Четкие интерфейсы между компонентами
   - Готовность к multiBOM интеграции

3. **Поддерживаемость**:
   - Читаемый код (~100-200 строк на модуль)
   - Четкое разделение ответственности
   - Логика переходов в одном месте

### Результаты тестирования:
- MP5 данные корректно загружаются (dt=153 минут/день)
- Статусы обновляются правильно
- На последнем дне `dn=0` (корректное поведение)
- Детерминированные результаты

---

## Следующие шаги

### Ближайшие задачи:
1. ✅ Реализовать базовую модель с states
2. ⏳ Создать RTC модули для каждого состояния
3. ⏳ Реализовать централизованное квотирование
4. ⏳ Создать единую функцию переходов
5. ⏳ Реализовать assembly_trigger при инициализации
6. ⏳ Протестировать на реальных данных

### Долгосрочные планы:
1. Интеграция с multiBOM архитектурой
2. Добавление модуля спавна новых агентов
3. Оптимизация квотирования для 10K+ агентов
4. Создание визуализации переходов состояний
5. Разработка системы метрик и мониторинга

---

## Приложение: Сравнение с V1

| Аспект | V1 (sim_master) | V2 (state-based) |
|--------|-----------------|------------------|
| Размер кода | 2000+ строк | ~100-200 строк/модуль |
| Архитектура | Монолит | Микросервисы |
| GPU эффективность | Warp divergence | Оптимальная |
| Квотирование | Дублирование в 4 местах | Централизованное |
| Расширяемость | Сложная | Простая |
| Тестируемость | Затруднена | Модульная |
| Переходы состояний | Распределены | В одном месте |
