# V2 State-based Architecture

## Дата создания: 2024-12-22

## Основные принципы

### 1. Использование FLAME GPU States вместо status_id

**Было:**
- Переменная `status_id` (0,1,2,3,4,5,6)
- Все агенты выполняют все функции
- Проверка статуса внутри каждой RTC функции

**Стало:**
- Агенты находятся в состояниях (states)
- Функции привязаны к конкретным состояниям
- GPU автоматически фильтрует агентов

### Технические решения

**MacroProperty для MP5:**
- Используется из-за ограничения размера PropertyArray (~10K элементов)
- MP5: 286 frames × 4001 days = 1,144,286 элементов
- Инициализация через HostFunction один раз на step=0
- Полностью изолировано от логики обработки статусов

**Квотирование без атомарных операций:**
- Менеджер квот выполняется одним агентом
- Читает ops_counter в локальную переменную
- Распределяет через внутренний счетчик
- Остаток логируется/используется для спавна

### 2. Разделение логики изменения состояния

**Было:**
- Каждая RTC функция статуса может менять status_id
- Дублирование логики квотирования
- Сложные зависимости между функциями

**Стало:**
- RTC функции статусов только:
  - Обновляют наработки (sne, ppr)
  - Устанавливают intent флаги
  - НЕ меняют состояние агента
- Единая RTC функция в конце степа меняет состояния

## Архитектура States

### Основные состояния (соответствуют status_id):
- `state_0` - Неактивный
- `state_1` - Поставка  
- `state_2` - Летный
- `state_3` - Ожидание капремонта
- `state_4` - В капремонте
- `state_5` - Хранение
- `state_6` - Списан

### Дополнительные переменные агента:
```
intent_flags:
- wants_ops: bool (хочет квоту на эксплуатацию)
- wants_repair: bool (нужен переход в ремонт)
- wants_storage: bool (нужен переход в хранение)
- wants_writeoff: bool (нужно списание)

quota_flags:
- has_ops_ticket: bool (получил квоту)
```

## Порядок выполнения на каждом степе

### Фаза 1: Обновление состояний (параллельно по states)
1. `rtc_state_0` - обработка неактивных
2. `rtc_state_1` - обработка поставки
3. `rtc_state_2` - обработка летных (sne+=dt, ppr+=dt, проверка ll/oh/br)
4. `rtc_state_3` - обработка ожидающих капремонт
5. `rtc_state_4` - обработка в капремонте (repair_days++)
6. `rtc_state_5` - обработка в хранении
7. `rtc_state_6` - обработка списанных (неизменяемые)

### Фаза 2: Квотирование (последовательно по приоритетам)
1. `rtc_quota_collect_intents` - сбор всех intent флагов
2. `rtc_quota_manager` - распределение квот с учетом приоритетов:
   - Приоритет 1: state_2 (летные)
   - Приоритет 2: state_3 (ожидание)
   - Приоритет 3: state_5 (хранение)
   - Приоритет 4: state_1 (поставка)
3. `rtc_quota_distribute_tickets` - установка has_ops_ticket

### Фаза 3: Переходы состояний (единая функция)
1. `rtc_state_transitions` - меняет состояния на основе:
   - intent флагов
   - quota флагов
   - бизнес-правил переходов

## Преимущества новой архитектуры

1. **Эффективность GPU**:
   - Нет warp divergence
   - Функции выполняются только для нужных агентов
   - Лучшее использование кеша

2. **Чистота кода**:
   - Каждая функция отвечает за одну задачу
   - Нет дублирования логики
   - Легче тестировать

3. **Масштабируемость**:
   - Готова для тысяч агентов
   - Оптимальное использование GPU

4. **Поддерживаемость**:
   - Логика переходов в одном месте
   - Четкое разделение ответственности
   - Проще добавлять новые состояния

## Правила реализации

1. **RTC функции состояний**:
   - НЕ меняют state агента
   - Только устанавливают intent флаги
   - Обновляют рабочие переменные (sne, ppr, repair_days)

2. **Квотирование**:
   - Централизованное управление
   - Атомарные операции через MacroProperty
   - Четкие приоритеты

3. **Переходы состояний**:
   - Только в rtc_state_transitions
   - На основе флагов и правил
   - Детерминированные

## Структура RTC модулей

### Принцип: Отдельная RTC функция для каждого state

Каждое состояние имеет свою RTC функцию, что обеспечивает:
- Модульность и управляемость кода
- Оптимальную производительность GPU (нет ветвлений)
- Простоту тестирования и отладки

### Файловая структура модулей:
```
code/sim_v2/
├── rtc_state_0_inactive.py     # Логика неактивных агентов
├── rtc_state_1_supply.py        # Логика поставки
├── rtc_state_2_flying.py        # Логика летных (sne, ppr, проверки)
├── rtc_state_3_waiting.py       # Логика ожидания ремонта
├── rtc_state_4_repair.py        # Логика в ремонте
├── rtc_state_5_storage.py       # Логика хранения
├── rtc_state_6_writeoff.py      # Логика списанных
├── rtc_quota_manager.py         # Централизованное квотирование
└── rtc_state_transitions.py    # Переходы между состояниями
```

### Выполнение на GPU:
- FLAME GPU предварительно сортирует агентов по состояниям
- Каждая RTC функция запускается только для агентов в соответствующем состоянии
- Функции разных состояний выполняются параллельно в рамках одного слоя
- Внутри каждой группы агенты обрабатываются параллельно

### Порядок слоев на каждом степе:

0. **Слой инициализации MP5** (только step=0):
   - HostFunction загружает MP5 данные в MacroProperty
   - Выполняется один раз в начале симуляции
   - Полностью изолирован от логики статусов

1. **Слой состояний** (параллельное выполнение):
   - Все rtc_state_X функции добавлены в один слой
   - GPU автоматически фильтрует и выполняет только для нужных агентов
   - Нет взаимных зависимостей между функциями

2. **Слой квотирования** (последовательное выполнение):
   - Менеджер квот читает ops_counter один раз
   - Распределяет квоты по приоритетам через внутренние переменные
   - Логирует остаток для спавна
   - НЕ использует атомарные операции

3. **Слой переходов** (единая функция):
   - Анализ всех флагов
   - Применение бизнес-правил
   - Атомарная смена состояний

## Важные архитектурные решения

### Загрузка OH при создании агентов
- Значение `oh` (overhaul hours) определяется при создании агентов из MP1
- Логика: для group_by=1 берём oh_mi8, для group_by=2 берём oh_mi17
- Это убирает необходимость определять oh в RTC функциях
- Упрощает RTC логику и делает её более производительной

### Обработка статуса 6 (списанные)

**Для агентов, изначально в статусе 6 (`s6_started = 0`):**
- RTC функция выходит без изменений
- Все переменные остаются неизменными
- Специальное копирование данных НЕ требуется

**Для агентов, перешедших в статус 6 (`s6_started = 1`):**
- Ведется счетчик дней `s6_days` до времени списания `partout_time`
- При достижении `s6_days == partout_time` устанавливается `partout_trigger = 1`
- После достижения порога счетчик перестает расти
- Это моделирует процесс ожидания до снятия агрегатов с планера
- **Важно**: планер является корнем сборки multiBOM, время `partout_time` дает возможность снять агрегаты перед списанием

### Обработка статуса 4 (в ремонте) и assembly_trigger

**Во время ремонта (RTC логика):**
- За `assembly_time` дней до окончания ремонта устанавливается `assembly_trigger = 1`
- Формула: если `(repair_time - repair_days) == assembly_time`, то триггер активируется
- Это сигнализирует о необходимости начать сборку агрегатов к планеру

**При инициализации агентов (ВАЖНЫЙ ПРОБЕЛ):**
- Для агентов, изначально в статусе 4, нужно проверить условие при создании
- Если `repair_time - repair_days > assembly_time`, то `assembly_trigger = 1`
- Это означает, что время сборки уже прошло, и агрегаты должны быть немедленно собраны
- **Цель**: сигнал субмодели multiBOM для сборки агрегатов к parent_id (aircraft_number планера)

### Фильтрация данных MP3
- Из ClickHouse загружаются ВСЕ строки heli_pandas (~7113)
- В frames_index попадают только планеры (group_by ∈ {1,2}, ~286 бортов)
- Агенты создаются только для планеров
- Данные других компонентов доступны, но не используются в симуляции

### Фиксированные размеры MacroProperty
- MAX_FRAMES определяется динамически из данных MP3/MP5
- MAX_DAYS = 4000 (фиксированный размер буфера)
- MAX_SIZE = MAX_FRAMES * (MAX_DAYS + 1)
- Все MacroProperty создаются с фиксированными размерами
- MP5 инициализируется через HostFunction только на step=0

## Следующие шаги

1. Реализовать базовую модель с states
2. Создать отдельные RTC модули для каждого состояния
3. Реализовать централизованное квотирование
4. Создать единую функцию переходов
5. Протестировать на реальных данных
