<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Transitions Viewer</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: Arial, Helvetica, sans-serif; margin: 24px; }
    h1, h2 { margin: 0 0 8px; }
    .meta { color: #666; font-size: 12px; margin-bottom: 16px; }
    .section { margin-bottom: 20px; }
    .states { display: flex; flex-wrap: wrap; gap: 8px; }
    .state-badge { background: #2a5bd7; color: white; padding: 3px 8px; border-radius: 10px; font-size: 12px; }
    table.matrix { width: 100%; border-collapse: collapse; table-layout: fixed; }
    table.matrix th, table.matrix td { border: 1px solid #ccc; padding: 6px; vertical-align: top; }
    table.matrix th { background: #f3f3f3; }
    .from-header { text-align: left; }
    .empty { color: #888; text-align: center; }
    details.rule-card { margin: 6px 0; border: 1px solid #ddd; border-radius: 6px; padding: 6px; background: #fafafa; }
    summary { cursor: pointer; list-style: none; }
    summary::-webkit-details-marker { display: none; }
    .badge { display: inline-block; padding: 2px 6px; border-radius: 10px; background: #2a5bd7; color: white; font-size: 11px; margin-right: 6px; }
    .rule-id { font-weight: 600; margin-right: 8px; }
    .rule-owner { color: #666; font-size: 11px; }
    .rule-body { margin-top: 8px; }
    .rule-section { margin-bottom: 6px; }
    .label { font-size: 11px; color: #444; text-transform: uppercase; }
    .value { font-size: 12px; white-space: pre-wrap; }
    .value.pre, .value.post { font-family: monospace; }
    .notes { font-size: 11px; color: #666; }
    .arrow { color: #2a5bd7; }
  </style>
</head>
<body>
  <h1>Transitions Viewer</h1>
  <div class="meta">Generated from config/transitions/transitions_rules.json and quota_rules.json at 2026-01-30 17:39:34 UTC</div>
  <div class="meta">Run: python3 tools/transitions_viewer/build_transitions_viewer.py</div>
  <div id="app"></div>
  <script>
    const TRANSITIONS_DATA = {"transitions": {"version": 8, "architecture": "LIMITER V8 (single-phase, RepairLine + Adaptive Steps)", "matrix": {"from": "state", "to": "state"}, "states": {"0": "spawn (boundary)", "1": "inactive", "2": "operations", "3": "serviceable", "4": "repair", "5": "reserve (unused)", "6": "storage (terminal)", "7": "unserviceable"}, "variables": ["state", "intent_state", "sne", "ppr", "dt_next", "ll", "oh", "br", "limiter", "repair_days", "repair_time", "repair_line_id", "free_days", "group_by", "current_day", "exit_date", "idx", "threshold_s3", "threshold_s7", "threshold_s5", "demote_threshold", "quota_left", "line_id", "acn", "adaptive_days"], "derived": [{"name": "sne_next", "expr": "sne + dt_next"}, {"name": "ppr_next", "expr": "ppr + dt_next"}], "rules": [{"id": "ops_to_storage_ll_v8", "from": 2, "to": 6, "pre": {"expr": "sne_next >= ll"}, "post": {"all": [{"expr": "state == 6"}, {"expr": "limiter == 0"}]}, "owner_module": "rtc_state_transitions_v8", "notes": "V8: списание по LL (next-day dt). Приоритет 1."}, {"id": "ops_to_storage_br_v8", "from": 2, "to": 6, "pre": {"expr": "ppr_next >= oh AND br > 0 AND sne_next >= br"}, "post": {"all": [{"expr": "state == 6"}, {"expr": "limiter == 0"}]}, "owner_module": "rtc_state_transitions_v8", "notes": "V8: списание по BR (ремонт нерентабелен). Приоритет 2."}, {"id": "ops_to_unsvc_v8", "from": 2, "to": 7, "pre": {"expr": "ppr_next >= oh AND NOT (br > 0 AND sne_next >= br)"}, "post": {"all": [{"expr": "state == 7"}, {"expr": "repair_line_id == 0xFFFFFFFF"}]}, "owner_module": "rtc_state_transitions_v8", "notes": "V8: уход в unserviceable по OH; storage отфильтрован по BR."}, {"id": "ops_hold_v8", "from": 2, "to": 2, "pre": {"expr": "sne_next < ll AND ppr_next < oh AND limiter > 0"}, "post": {"all": [{"expr": "state == 2"}]}, "owner_module": "rtc_state_transitions_v8", "notes": "V8: остаётся в operations (инкремент SNE/PPR, декремент limiter)."}, {"id": "demote_ops_to_svc_v8", "from": 2, "to": 3, "pre": {"expr": "idx < demote_threshold"}, "post": {"all": [{"expr": "state == 3"}]}, "owner_module": "rtc_demote_ops_v7", "notes": "Квоты: демоут ops → serviceable при избытке (по idx)."}, {"id": "p1_svc_to_ops_v8", "from": 3, "to": 2, "pre": {"expr": "idx >= threshold_s3 AND quota_left > 0"}, "post": {"all": [{"expr": "state == 2"}]}, "owner_module": "rtc_svc_to_ops_v7", "notes": "Квоты P1: serviceable → operations (threshold_s3)."}, {"id": "p2_unsvc_to_ops_v8", "from": 7, "to": 2, "pre": {"expr": "repair_days == 0 AND repair_line_id == 0xFFFFFFFF AND free_days >= repair_time AND quota_left > 0"}, "post": {"all": [{"expr": "state == 2"}, {"expr": "ppr == 0"}, {"expr": "repair_line_id = line_id"}, {"expr": "line.free_days = 0"}, {"expr": "line.aircraft_number = acn"}]}, "owner_module": "rtc_promote_unsvc_v8", "notes": "Квоты P2: unserviceable → operations (RepairLine)."}, {"id": "p3_inactive_to_ops_v8", "from": 1, "to": 2, "pre": {"expr": "free_days >= repair_time AND quota_left > 0"}, "post": {"all": [{"expr": "state == 2"}, {"expr": "repair_line_id = line_id"}, {"expr": "line.free_days = 0"}]}, "owner_module": "rtc_promote_inactive_v8", "notes": "Квоты P3: inactive → operations (RepairLine)."}, {"id": "repair_to_svc_v8", "from": 4, "to": 3, "pre": {"expr": "current_day >= exit_date"}, "post": {"all": [{"expr": "state == 3"}, {"expr": "repair_days == 0"}]}, "owner_module": "rtc_repair_to_svc_v7", "notes": "Детерминированный выход из ремонта по exit_date."}, {"id": "repair_hold_v8", "from": 4, "to": 4, "pre": {"expr": "current_day < exit_date"}, "post": {"all": [{"expr": "state == 4"}]}, "owner_module": "rtc_repair_to_svc_v7", "notes": "Остаётся в ремонте до exit_date."}, {"id": "serviceable_hold_v8", "from": 3, "to": 3, "pre": {"expr": "true"}, "post": {"all": [{"expr": "state == 3"}]}, "owner_module": "rtc_states_stub", "notes": "Holding в serviceable."}, {"id": "unserviceable_hold_v8", "from": 7, "to": 7, "pre": {"expr": "true"}, "post": {"all": [{"expr": "state == 7"}]}, "owner_module": "rtc_states_stub", "notes": "Holding в unserviceable (ожидание RepairLine)."}]}, "quota": {"version": 8, "architecture": "LIMITER V8 quota (MessageBucket + RepairLine)", "quota_flow": [{"id": "reset_flags", "owner_module": "rtc_reset_flags_v7", "notes": "Сброс promote/demote флагов перед квотированием."}, {"id": "reset_buffers", "owner_module": "rtc_reset_buffers_v7", "notes": "Сброс буферов подсчёта перед сбором."}, {"id": "count_agents", "owner_module": "rtc_count_*", "notes": "Подсчёт по состояниям и готовность unsvc/inactive."}, {"id": "repair_line_slots", "owner_module": "rtc_repair_line_slots_v8", "notes": "Сбор доступных RepairLine слотов."}, {"id": "demote_ops", "owner_module": "rtc_demote_ops_v7", "notes": "Решение демоута ops → serviceable."}, {"id": "promote_p1_serviceable", "owner_module": "rtc_promote_svc_v7", "notes": "P1: serviceable → operations (по типам)."}, {"id": "promote_p2_unsvc", "owner_module": "rtc_promote_unsvc_v8", "notes": "P2: unserviceable → operations (общий RepairLine пул)."}, {"id": "promote_p3_inactive", "owner_module": "rtc_promote_inactive_v8", "notes": "P3: inactive → operations (после P2)."}, {"id": "spawn_p4_dynamic", "owner_module": "rtc_spawn_dynamic_mgr_v8", "notes": "P4: динамический spawn при оставшемся дефиците."}], "selection_rules": [{"id": "demote_by_idx", "expr": "idx < demote_threshold", "notes": "Демоут: меньший idx демоутится первым."}, {"id": "p1_threshold_s3", "expr": "idx >= threshold_s3", "notes": "P1: serviceable → operations по порогу."}, {"id": "p2_threshold_s7", "expr": "idx >= threshold_s7 AND repair_days == 0 AND repair_line_id == 0xFFFFFFFF", "notes": "P2: unsvc готов при repair_days==0 и нет назначенной линии."}, {"id": "p3_threshold_s5", "expr": "idx >= threshold_s5", "notes": "P3: inactive → operations (после P2)."}], "repair_line_rules": [{"id": "free_days_increment", "expr": "free_days += adaptive_days", "notes": "Каждый шаг линии наращивают free_days."}, {"id": "line_available", "expr": "aircraft_number == 0 AND free_days >= repair_time", "notes": "Линия доступна, если свободна и накопила repair_time."}, {"id": "assign_on_promote", "expr": "on promote: free_days = 0; aircraft_number = acn; repair_line_id = line_id", "notes": "Назначение RepairLine при P2/P3."}], "spawn_rules": [{"id": "deficit_formula", "expr": "deficit = target_ops - curr_ops - used(P1,P2,P3)", "notes": "Дефицит считается после commit P1/P2/P3."}, {"id": "spawn_ticket", "expr": "SpawnMgr -> MessageBucket(key=100+group_by) with {need, base_idx}", "notes": "Тикеты создают агентов сразу в operations."}], "message_bucket": {"quota_bucket": {"keys": [1, 2], "payload": ["quota_s3", "quota_s7", "quota_s5", "threshold_s3", "threshold_s7", "threshold_s5", "demote_threshold"], "notes": "QM отправляет broadcast по ключу group_by (Mi-8/Mi-17)."}, "spawn_bucket": {"keys": [101, 102], "payload": ["need", "base_idx"], "notes": "SpawnMgr отправляет дефицит и базовый idx."}}}};
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text ?? '';
      return div.innerHTML;
    }
    function formatCondition(cond) {
      if (!cond) return '';
      if (cond.all) return cond.all.map(c => escapeHtml(c.expr)).join('\nAND\n');
      if (cond.any) return cond.any.map(c => escapeHtml(c.expr)).join('\nOR\n');
      if (cond.expr) return escapeHtml(cond.expr);
      return '';
    }
    function renderRuleCard(rule, targetLabel) {
      let html = '<details class="rule-card">';
      const owner = rule.owner_module ? escapeHtml(rule.owner_module) : '';
      html += owner
        ? `<summary><span class=\"badge\">rule</span><span class=\"rule-owner\">${owner}</span></summary>`
        : `<summary><span class=\"badge\">rule</span><span class=\"rule-id\">${escapeHtml(rule.id)}</span></summary>`;
      html += '<div class="rule-body">';
      if (rule.pre) html += `<div class="rule-section"><div class="label">pre</div><div class="value pre">${formatCondition(rule.pre)}</div></div>`;
      if (rule.post) html += `<div class="rule-section"><div class="label">post</div><div class="value post">${formatCondition(rule.post)}</div></div>`;
      if (rule.effects) html += `<div class=\"rule-section\"><div class=\"label\">effects</div><div class=\"value\">${escapeHtml(JSON.stringify(rule.effects))}</div></div>`;
      if (rule.notes) html += `<div class="notes">${escapeHtml(rule.notes)}</div>`;
      html += '</div></details>';
      return html;
    }
    function getIds(mapObj, rules, key) {
      const ids = Object.keys(mapObj || {}).map(Number).filter(n => !Number.isNaN(n));
      if (ids.length) return ids.sort((a, b) => a - b);
      const vals = (rules || []).map(r => r[key]);
      return Array.from(new Set(vals)).filter(n => n !== undefined).sort((a, b) => a - b);
    }
    function renderLegend(title, mapObj) {
      const ids = Object.keys(mapObj || {}).map(Number).filter(n => !Number.isNaN(n)).sort((a, b) => a - b);
      if (!ids.length) return '';
      let html = `<div class=\"section\"><h2>${escapeHtml(title)}</h2><div class=\"states\">`;
      ids.forEach(id => {
        const name = mapObj?.[String(id)] || `${title.toLowerCase()}_${id}`;
        html += `<div class=\"state-badge\">${id}: ${escapeHtml(name)}</div>`;
      });
      html += '</div></div>';
      return html;
    }
    function renderMatrixBlock(data, title) {
      const app = document.getElementById('app');
      const matrix = data.matrix || { from: 'state', to: 'state' };
      const fromMap = matrix.from === 'intent' ? (data.intents || {}) : (data.states || {});
      const toMap = matrix.to === 'intent' ? (data.intents || {}) : (data.states || {});
      const fromIds = getIds(fromMap, data.rules, 'from');
      const toIds = getIds(toMap, data.rules, 'to');
      let html = '';
      html += `<div class=\"section\"><h2>${escapeHtml(title)}</h2></div>`;
      html += renderLegend('States', data.states);
      if (data.intents) html += renderLegend('Intents', data.intents);
      if (data.derived?.length) {
        html += '<div class=\"section\"><h2>Derived</h2>';
        data.derived.forEach(item => {
          html += `<div>${escapeHtml(item.name)} = ${escapeHtml(item.expr)}</div>`;
        });
        html += '</div>';
      }
      html += `<div class=\"section\"><h2>Matrix (${escapeHtml(matrix.from)} → ${escapeHtml(matrix.to)})</h2><table class=\"matrix\">`;
      html += `<thead><tr><th>${escapeHtml(matrix.from)} \\ ${escapeHtml(matrix.to)}</th>`;
      toIds.forEach(id => {
        const name = toMap?.[String(id)] || `${matrix.to}_${id}`;
        html += `<th>${id}<br><small>${escapeHtml(name)}</small></th>`;
      });
      html += '</tr></thead><tbody>';
      fromIds.forEach(fromId => {
        const fromName = fromMap?.[String(fromId)] || `${matrix.from}_${fromId}`;
        html += `<tr><th class=\"from-header\">${fromId}<br><small>${escapeHtml(fromName)}</small></th>`;
        toIds.forEach(toId => {
          const cellRules = (data.rules || []).filter(r => r.from === fromId && r.to === toId);
          html += '<td>';
          if (!cellRules.length) {
            html += '<div class=\"empty\">—</div>';
          } else {
            cellRules.forEach(rule => {
              html += renderRuleCard(rule);
            });
          }
          html += '</td>';
        });
        html += '</tr>';
      });
      html += '</tbody></table></div>';
      if ((data.rules || []).length === 0) {
        html = '<div class=\"section\"><div class=\"notes\">Rules list is empty.</div></div>' + html;
      }
      app.innerHTML += html;
    }
    function renderQuotaSection(title, items) {
      if (!items || !items.length) return '';
      let html = `<div class=\"section\"><h2>${escapeHtml(title)}</h2>`;
      items.forEach(item => {
        html += '<details class=\"rule-card\">';
        const owner = item.owner_module ? escapeHtml(item.owner_module) : '';
        const id = item.id ? escapeHtml(item.id) : 'item';
        html += owner
          ? `<summary><span class=\"badge\">rule</span><span class=\"rule-owner\">${owner}</span></summary>`
          : `<summary><span class=\"badge\">rule</span><span class=\"rule-id\">${id}</span></summary>`;
        html += '<div class=\"rule-body\">';
        if (item.expr) html += `<div class=\"rule-section\"><div class=\"label\">expr</div><div class=\"value pre\">${escapeHtml(item.expr)}</div></div>`;
        if (item.notes) html += `<div class=\"notes\">${escapeHtml(item.notes)}</div>`;
        html += '</div></details>';
      });
      html += '</div>';
      return html;
    }
    function renderMessageBucket(bucket, title) {
      if (!bucket) return '';
      let html = `<div class=\"section\"><h2>${escapeHtml(title)}</h2>`;
      html += `<div><strong>keys</strong>: ${escapeHtml((bucket.keys || []).join(', '))}</div>`;
      html += `<div><strong>payload</strong>: ${escapeHtml((bucket.payload || []).join(', '))}</div>`;
      if (bucket.notes) html += `<div class=\"notes\">${escapeHtml(bucket.notes)}</div>`;
      html += '</div>';
      return html;
    }
    function renderQuotaBlock(quota) {
      let html = '<div class=\"section\"><h2>Quota Logic</h2></div>';
      html += renderQuotaSection('Quota Flow', quota.quota_flow || []);
      html += renderQuotaSection('Selection Rules', quota.selection_rules || []);
      html += renderQuotaSection('RepairLine Rules', quota.repair_line_rules || []);
      html += renderQuotaSection('Spawn Rules', quota.spawn_rules || []);
      if (quota.message_bucket) {
        html += renderMessageBucket(quota.message_bucket.quota_bucket, 'MessageBucket: Quota');
        html += renderMessageBucket(quota.message_bucket.spawn_bucket, 'MessageBucket: Spawn');
      }
      return html;
    }
    function renderViewer(data) {
      const app = document.getElementById('app');
      app.innerHTML = '';
      renderMatrixBlock(data.transitions, 'Transitions (state → state)');
      app.innerHTML += renderQuotaBlock(data.quota || {});
    }
    renderViewer(TRANSITIONS_DATA);
  </script>
</body>
</html>